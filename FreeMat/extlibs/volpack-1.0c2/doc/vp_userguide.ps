%!PS-Adobe-1.0
%%Title: VolPack User's Guide
%%DocumentFonts: Times-Roman Times-Bold Times-Italic Courier Courier-Bold Courier-Oblique
%%Creator: NCSA Mosaic, Postscript by Ameet Raval & Frans van Hoesel
%%Pages: (atend)
%%EndComments
save
/D {def} def /E {exch} D
/M {moveto} D
/S {show} D
/R {rmoveto} D
/L {lineto} D
/RL {rlineto} D
/SQ {newpath 0 0 M 0 1 L 1 1 L 1 0 L closepath} D
/U {gsave currentpoint currentfont /FontInfo get /UnderlinePosition get
 0 E currentfont /FontMatrix get dtransform E pop add newpath moveto
 dup stringwidth rlineto stroke grestore S } D
/B {/r E D gsave -13 0  R currentpoint 
  newpath r 0 360 arc closepath fill grestore } D
/OB {/r E D gsave -13 0  R currentpoint 
  newpath r 0 360 arc closepath stroke grestore } D
/NP {xmargin topmargin translate scalfac dup scale } D
/HR {/l E D gsave l 0 RL  stroke grestore } D
/SF {E findfont E scalefont setfont } D
/FF {/Courier } D
/FB {/Courier-Bold } D
/FI {/Courier-Oblique } D
/RF {/Times-Roman} D
/BF {/Times-Bold} D
/IF {/Times-Italic} D
/reencodeISO {
dup dup findfont dup length dict begin
{ 1 index /FID ne { def }{ pop pop } ifelse } forall
/Encoding ISOLatin1Encoding D
currentdict end definefont
} D
/ISOLatin1Encoding [
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
/parenleft/parenright/asterisk/plus/comma/minus/period/slash
/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve
/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut
/ogonek/caron/space/exclamdown/cent/sterling/currency/yen/brokenbar
/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine
/guillemotright/onequarter/onehalf/threequarters/questiondown
/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
/yacute/thorn/ydieresis
] D
[RF BF IF FF FB FI] {reencodeISO D} forall
/xmargin 43 D
/topmargin 720 D
/scalfac 0.54351 D
%%EndProlog
%%Page: 1 1
save
NP
0 -20 M
BF 24 SF
0 -20 R
(VolPack User's Guide)S
0 -48 M
0 -65 M
IF 17 SF
0 -13 R
(Version 2.0beta1)S
RF 17 SF
( )S
0 -84 M
0 -101 M
BF 18 SF
0 -15 R
(Table of Contents)S
0 -122 M
0 -139 M
RF 17 SF
0 -13 R
(Section 1: Overview )S
76 -158 M
0 -13 R
(1. )S
(Introduction to VolPack )S
76 -177 M
0 -13 R
(2. )S
(The Volume Rendering Pipeline )S
76 -196 M
0 -13 R
(3. )S
(Data Structures and Rendering Algorithms )S
0 -215 M
0 -13 R
(Section 2: Using VolPack )S
76 -234 M
0 -13 R
(1. )S
(Include Files and Libraries )S
76 -253 M
0 -13 R
(2. )S
(Rendering Contexts )S
76 -272 M
0 -13 R
(3. )S
(Volumes )S
76 -291 M
0 -13 R
(4. )S
(Classification )S
76 -310 M
0 -13 R
(5. )S
(Classified Volumes )S
76 -329 M
0 -13 R
(6. )S
(Min-Max Octrees )S
76 -348 M
0 -13 R
(7. )S
(View Transformations )S
76 -367 M
0 -13 R
(8. )S
(Shading and Lighting )S
76 -386 M
0 -13 R
(9. )S
(Images )S
68 -405 M
0 -13 R
(10. )S
(Rendering )S
68 -424 M
0 -13 R
(11. )S
(State Variables )S
68 -443 M
0 -13 R
(12. )S
(Utility Functions )S
68 -462 M
0 -13 R
(13. )S
(Result Codes and Error Handling )S
0 -481 M
0 -13 R
(Section 3: Tips and Pointers )S
76 -500 M
0 -13 R
(1. )S
(Maximizing Rendering Speed )S
76 -519 M
0 -13 R
(2. )S
(Maximizing Image Quality )S
76 -538 M
0 -13 R
(3. )S
(Software Support )S
76 -557 M
0 -13 R
(4. )S
(Obtaining the Software )S
48 -576 M
0 -593 M
BF 18 SF
0 -15 R
(Section 1: Overview )S
0 -614 M
0 -631 M
BF 17 SF
0 -14 R
(Introduction to VolPack )S
0 -651 M
0 -668 M
RF 17 SF
0 -13 R
(VolPack is a portable software library for volume rendering. It is based on a new family of fast volume rendering)S
0 -687 M
0 -13 R
(algorithms \(see )S
(Philippe Lacroute )S
(and )S
(Marc Levoy )S
(, )S
IF 17 SF
(Fast Volume Rendering Using a Shear-Warp Factorization of)S
0 -706 M
0 -13 R
(the Viewing Transformation)S
RF 17 SF
(, Proc. SIGGRAPH '94 \(Orlando, Florida, July 24-29, 1994\). In Computer Graphics)S
0 -725 M
0 -13 R
(Proceedings, Annual Conference Series, 1994, ACM SIGGRAPH, pp. 451-458\). The library has the following)S
0 -744 M
0 -13 R
(features: )S
0 -763 M
48 -780 M
0 -9 R
 3.454545 B
0 -4 R
(Renders data sampled on a regular, three-dimensional grid. )S
48 -799 M
0 -9 R
 3.454545 B
0 -4 R
(Supports user-specified transfer functions for both opacity and color. )S
48 -818 M
0 -9 R
 3.454545 B
0 -4 R
(Provides a shading model with directional light sources, multiple material types with different reflective)S
48 -837 M
0 -13 R
(properties, depth cueing, and shadows. )S
48 -856 M
0 -9 R
 3.454545 B
0 -4 R
(Produces color \(24 bits/pixel\) or grayscale \(8 bits/pixel\) renderings, with or without an alpha channel. )S
48 -875 M
0 -9 R
 3.454545 B
0 -4 R
(Supports arbitrary affine view transformations. )S
48 -894 M
0 -9 R
 3.454545 B
0 -4 R
(Supports a flexible data format that allows an arbitrary C structure to be associated with each grid point. )S
48 -913 M
0 -9 R
 3.454545 B
0 -4 R
(Achieves very fast rendering times without specialized hardware. )S
48 -932 M
0 -949 M
0 -13 R
(The library is intended for use in C or C++ programs but may be useful with other programming languages. The)S
0 -968 M
0 -13 R
(current implementation does not support perspective projections or clipping planes. These features will be added in a)S
0 -987 M
0 -13 R
(future release. )S
0 -1006 M
0 -1023 M
0 -13 R
(The remainder of this section contains a brief introduction to the conceptual volume rendering pipeline used by)S
0 -1042 M
0 -13 R
(VolPack, followed by a high-level description of the data structures and algorithms used by the library. This)S
0 -1061 M
0 -13 R
(background material lays the foundation for )S
(Section 2)S
( which describes each of the routines provided by VolPack.)S
0 -1080 M
0 -13 R
(The routines are grouped by function and are presented roughly in the order that they would be called in a typical)S
0 -1099 M
0 -13 R
(application. More detailed descriptions of each command can be found by consulting the man pages for VolPack.)S
0 -1118 M
0 -13 R
(Finally, )S
(Section 3)S
( covers some tips for maximizing rendering performance and image quality, and describes how to)S
0 -1137 M
0 -13 R
(obtain the VolPack software. )S
0 -1156 M
0 -1173 M
BF 17 SF
0 -14 R
(The Volume Rendering Pipeline )S
0 -1193 M
0 -1210 M
RF 17 SF
0 -13 R
(The input to the volume renderer is a three-dimensional array of data. Each element of the array is a C structure)S
showpage restore
%%Page: 2 2
save
NP
RF 17 SF
0 0 M
0 -13 R
(containing any number of fields of data, such as tissue density or temperature. Each element is called a "voxel." The)S
0 -19 M
0 -13 R
(first stage in the volume rendering pipeline is to )S
IF 17 SF
(classify)S
RF 17 SF
( the volume data, which means to assign an opacity to each)S
0 -38 M
0 -13 R
(voxel. Opacity is the inverse of transparency: an opacity of 0.0 indicates a fully-transparent voxel, while an opacity)S
0 -57 M
0 -13 R
(of 1.0 indicates a voxel which completely occludes anything behind it. Intermediate values between 0.0 and 1.0)S
0 -76 M
0 -13 R
(indicate semi-transparent voxels. The purpose of classification is to assign low opacities to regions of the data set)S
0 -95 M
0 -13 R
(which are uninteresting or distracting and high opacities to regions of the data set which should be visible in the)S
0 -114 M
0 -13 R
(rendering. Intermediate opacity values are used for smooth transitions from transparent to opaque regions, and for)S
0 -133 M
0 -13 R
(effects such as semi-transparent voxels which should not completely occlude objects behind them. )S
0 -152 M
0 -169 M
0 -13 R
(VolPack provides a classification method based on lookup tables. To use this method you specify a transfer function)S
0 -188 M
0 -13 R
(which maps the scalar data in a particular array element into the opacity for that element. Alternatively you can)S
0 -207 M
0 -13 R
(implement other classification techniques such as context-sensitive segmentation and then provide VolPack with a)S
0 -226 M
0 -13 R
(pre-classified volume. )S
0 -245 M
0 -262 M
0 -13 R
(The second rendering stage is to assign a color to each voxel, an operation which is called )S
IF 17 SF
(shading)S
RF 17 SF
( \(or more)S
0 -281 M
0 -13 R
(precisely, )S
IF 17 SF
(lighting)S
RF 17 SF
(\). VolPack includes support for the standard Phong shading equation. To use this shading)S
0 -300 M
0 -13 R
(technique, the volume data is preprocessed before rendering in order to compute a gradient vector for each voxel.)S
0 -319 M
0 -13 R
(The gradient vector can then be used as a pseudo surface normal to compute how light reflects off of each voxel. The)S
0 -338 M
0 -13 R
(user specifies the position and color of one or more light sources, and the reflective properties of the volume data.)S
0 -357 M
0 -13 R
(See )S
IF 17 SF
(Computer Graphics: Principles and Practice)S
RF 17 SF
( \(Chapter 16, 2nd ed.\), by Foley, van Dam, Feiner and Hughes, for a)S
0 -376 M
0 -13 R
(detailed discussion of the Phong shading equation. Alternative shading models can be implemented through a)S
0 -395 M
0 -13 R
(callback function. )S
0 -414 M
0 -431 M
0 -13 R
(The third rendering stage is to specify a view transformation and to transform the volume accordingly. This step can)S
0 -450 M
0 -13 R
(be as simple as choosing the position from which to look at the volume, or it can include an arbitrary affine)S
0 -469 M
0 -13 R
(transformation of the volume including non-uniform scaling and shearing. The view transformation also specifies)S
0 -488 M
0 -13 R
(how the volume is projected onto a 2D image plane. )S
0 -507 M
0 -524 M
0 -13 R
(The fourth and final rendering stage is to composite the voxels into an image. Digital compositing is analogous to)S
0 -543 M
0 -13 R
(the compositing process used in the film industry: several layers of semi-transparent film are merged together into a)S
0 -562 M
0 -13 R
(final image. VolPack provides several rendering algorithms that use different techniques to accelerate the)S
0 -581 M
0 -13 R
(compositing stage. The next subsection briefly describes the available algorithms. )S
0 -600 M
0 -617 M
BF 17 SF
0 -14 R
(Data Structures and Rendering Algorithms )S
0 -637 M
0 -654 M
RF 17 SF
0 -13 R
(VolPack includes three rendering algorithms which are useful in different situations. The algorithms differ in the)S
0 -673 M
0 -13 R
(degree to which they trade flexibility for speed and in the type of preprocessing required before rendering. )S
0 -692 M
0 -709 M
0 -13 R
(The fastest algorithm allows the user to rapidly render a volume with any view transformation and with any shading)S
0 -728 M
0 -13 R
(parameters while keeping the classification fixed. This algorithm relies on a special data structure which contains)S
0 -747 M
0 -13 R
(run-length encoded, classified volume data. Depending on the volume size it can take several minutes to precompute)S
0 -766 M
0 -13 R
(the run-length encoded volume, so this algorithm is most suitable when many renderings will be made from the)S
0 -785 M
0 -13 R
(same volume without changing the classification. )S
0 -804 M
0 -821 M
0 -13 R
(The steps when using this algorithm to render a classified volume are: )S
0 -840 M
48 -857 M
0 -9 R
 3.454545 B
0 -4 R
(load the volume data )S
48 -876 M
0 -9 R
 3.454545 B
0 -4 R
(choose the classification function )S
48 -895 M
0 -9 R
 3.454545 B
0 -4 R
(precompute the classified volume )S
48 -914 M
0 -9 R
 3.454545 B
0 -4 R
(repeat: )S
96 -933 M
0 -9 R
 3.454545 OB
0 -4 R
(set the view and shading parameters )S
96 -952 M
0 -9 R
 3.454545 OB
0 -4 R
(render with )S
FF 17 SF
(vpRenderClassifiedVolume\(\))S
RF 17 SF
( )S
48 -971 M
0 -988 M
0 -13 R
(The second algorithm is useful in situations where the classification will be adjusted frequently. It also relies on a)S
0 -1007 M
0 -13 R
(special data structure: a min-max octree which contains the minimum and maximum values of each voxel field. This)S
0 -1026 M
0 -13 R
(data structure must be computed once when a new volume is acquired. The volume can then be rendered multiple)S
0 -1045 M
0 -13 R
(times with any opacity transfer function, any view transformation and any shading parameters. )S
0 -1064 M
0 -1081 M
0 -13 R
(The steps when using this algorithm to render an unclassified volume are: )S
0 -1100 M
48 -1117 M
0 -9 R
 3.454545 B
0 -4 R
(load the volume data )S
48 -1136 M
0 -9 R
 3.454545 B
0 -4 R
(precompute the min-max octree with )S
FF 17 SF
(vpCreateMinMaxOctree\(\))S
RF 17 SF
( )S
48 -1155 M
0 -9 R
 3.454545 B
0 -4 R
(repeat: )S
96 -1174 M
0 -9 R
 3.454545 OB
0 -4 R
(choose the classification function )S
96 -1193 M
0 -9 R
 3.454545 OB
0 -4 R
(set the view and shading parameters )S
96 -1212 M
0 -9 R
 3.454545 OB
0 -4 R
(render with )S
FF 17 SF
(vpRenderRawVolume\(\))S
RF 17 SF
( )S
showpage restore
%%Page: 3 3
save
NP
RF 17 SF
48 0 M
0 -17 M
0 -13 R
(Finally, the third algorithm does not use any precomputed data structures. In most cases it is significantly slower)S
0 -36 M
0 -13 R
(than the other two algorithms and is useful only if you wish to make a single rendering from a volume. The steps for)S
0 -55 M
0 -13 R
(using this algorithm are identical to the previous algorithm except that there is no need to compute the min-max)S
0 -74 M
0 -13 R
(octree. )S
0 -93 M
0 -110 M
BF 18 SF
0 -15 R
(Section 2: Using VolPack )S
0 -131 M
0 -148 M
RF 17 SF
0 -13 R
(This section describes how to use the routines provided by VolPack. For more specific information about a)S
0 -167 M
0 -13 R
(particular routine, consult the man pages provided with the library. )S
0 -186 M
0 -203 M
BF 17 SF
0 -14 R
(Include Files and Libraries )S
0 -223 M
0 -240 M
RF 17 SF
0 -13 R
(All of the definitions needed by a program which uses VolPack are included in the header file )S
FF 17 SF
(volpack.h)S
RF 17 SF
(. The)S
0 -259 M
0 -13 R
(program must be compiled with the VolPack library by including the switch )S
FF 17 SF
(-lvolpack)S
RF 17 SF
( on the compilation)S
0 -278 M
0 -13 R
(command line. Other useful free libraries you may wish to use are John Ousterhout's Tcl/Tk libraries to build a)S
0 -297 M
0 -13 R
(graphical user interface, and Jef Poskanzer's pbmplus library or Sam Leffler's TIFF library to store images. )S
0 -316 M
0 -333 M
0 -13 R
(The header file defines the following data types: )S
0 -352 M
48 -369 M
0 -10 R
 3.454545 B
FF 17 SF
0 -3 R
(vpContext)S
RF 17 SF
(: a rendering context. )S
48 -388 M
0 -10 R
 3.454545 B
FF 17 SF
0 -3 R
(vpResult)S
RF 17 SF
(: a result code. )S
48 -407 M
0 -10 R
 3.454545 B
FF 17 SF
0 -3 R
(vpVector3)S
RF 17 SF
(: a three-element double-precision vector. )S
48 -426 M
0 -10 R
 3.454545 B
FF 17 SF
0 -3 R
(vpVector4)S
RF 17 SF
(: a four-element double-precision vector. )S
48 -445 M
0 -10 R
 3.454545 B
FF 17 SF
0 -3 R
(vpMatrix3)S
RF 17 SF
(: a three-by-three double-precision matrix. )S
48 -464 M
0 -10 R
 3.454545 B
FF 17 SF
0 -3 R
(vpMatrix4)S
RF 17 SF
(: a four-by-four double-precision matrix. )S
48 -483 M
0 -500 M
BF 17 SF
0 -14 R
(Rendering Contexts )S
0 -520 M
0 -537 M
RF 17 SF
0 -13 R
(The first argument of most of the routines in the VolPack library is a )S
IF 17 SF
(rendering context)S
RF 17 SF
(, declared as a variable of)S
0 -556 M
0 -13 R
(type )S
FF 17 SF
(vpContext)S
RF 17 SF
(. A rendering context contains all of the information required to render a volume, including the)S
0 -575 M
0 -13 R
(classification and shading parameters, the view transformation, a description of the format of the volume, and)S
0 -594 M
0 -13 R
(private data structures used by the rendering routines. The contents of a rendering context are not directly accessible)S
0 -613 M
0 -13 R
(to the application programmer; instead, you use the routines provided by the library to set, modify and query the)S
0 -632 M
0 -13 R
(state in a context. A program can have multiple active contexts, for instance to render different volumes or to render)S
0 -651 M
0 -13 R
(the same volume with different parameters simultaneously. )S
0 -670 M
0 -687 M
0 -13 R
(To create a new context, use )S
FF 17 SF
(vpCreateContext\(\))S
RF 17 SF
(: )S
0 -706 M
0 -723 M
FF 14 SF
0 -10 R
(    vpContext *vpCreateContext\(\);)S
0 -738 M
0 -755 M
RF 17 SF
0 -13 R
(The return value is a pointer to the new context. It contains default values for most of the rendering parameters, but)S
0 -774 M
0 -13 R
(you can change all of them with the routines described later in this section. )S
0 -793 M
0 -810 M
0 -13 R
(To destroy a context and free the memory associated with it, use )S
FF 17 SF
(vpDestroyContext\(\))S
RF 17 SF
(: )S
0 -829 M
0 -846 M
FF 14 SF
0 -10 R
(    void vpDestroyContext\(vpContext *vpc\);)S
0 -861 M
0 -878 M
BF 17 SF
0 -14 R
(Volumes )S
0 -898 M
0 -915 M
RF 17 SF
0 -13 R
(A volume is simply a 3D array of data. The type of data can be almost anything, but if you choose to use the)S
0 -934 M
0 -13 R
(classification and shading routines provided by VolPack then you must supply the fields these routines require. You)S
0 -953 M
0 -13 R
(may also wish to precompute information required by your shader or classifier and store it in the voxel. Here is an)S
0 -972 M
0 -13 R
(example layout for a voxel: )S
0 -991 M
0 -1008 M
FF 14 SF
0 -10 R
(    typedef unsigned char Scalar;)S
0 -1023 M
0 -10 R
(    typedef unsigned short Normal;)S
0 -1038 M
0 -10 R
(    typedef unsigned char Gradient;)S
0 -1053 M
0 -10 R
(    typedef struct {)S
0 -1068 M
0 -10 R
(        Normal normal;)S
0 -1083 M
0 -10 R
(        Scalar scalar;)S
0 -1098 M
0 -10 R
(        Gradient gradient;)S
0 -1113 M
0 -10 R
(    } Voxel;)S
0 -1128 M
0 -1145 M
RF 17 SF
0 -13 R
(In this example the data stored in a voxel includes an 8-bit scalar value and two precomputed fields. The first)S
0 -1164 M
0 -13 R
(precomputed field is a surface normal vector encoded in a 16-bit field; this field is used by VolPack's shading)S
0 -1183 M
0 -13 R
(routines. The second precomputed field is the gradient-magnitude of the scalar value; this field can be used for)S
0 -1202 M
0 -13 R
(detecting surface boundaries during classification, for instance. )S
showpage restore
%%Page: 4 4
save
NP
RF 17 SF
0 0 M
0 -17 M
0 -13 R
(Note that the structure fields have been specified in the voxel structure in a very particular order. Many machines)S
0 -36 M
0 -13 R
(have alignment restrictions which require two-byte quantities to be aligned to two-byte boundaries, four-byte)S
0 -55 M
0 -13 R
(quantities to be aligned to four-byte boundaries, and so on. The compiler may have to insert wasted space in between)S
0 -74 M
0 -13 R
(fields to satisfy these requirements if you are not careful. Use the )S
FF 17 SF
(sizeof\(\))S
RF 17 SF
( operator to make sure the size of the)S
0 -93 M
0 -13 R
(voxel matches your expectations. )S
0 -112 M
0 -129 M
0 -13 R
(You should also place the fields which are required for shading first, followed by any other fields used only for)S
0 -148 M
0 -13 R
(classification. Ordering the fields this way makes it possible to store just the fields for shading when a classified)S
0 -167 M
0 -13 R
(volume is created for the fast rendering algorithm. This saves memory and improves cache performance. )S
0 -186 M
0 -203 M
0 -13 R
(Once you have decided on the format of your volume you must describe it to VolPack. To set the dimensions of the)S
0 -222 M
0 -13 R
(volume use )S
FF 17 SF
(vpSetVolumeSize)S
RF 17 SF
(: )S
0 -241 M
0 -258 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -273 M
0 -10 R
(    vpSetVolumeSize\(vpContext *vpc, int xlen, int ylen, int zlen\);)S
0 -288 M
0 -305 M
RF 17 SF
0 -13 R
(The first argument is the context whose state you wish to modify, and the remaining arguments are the number of)S
0 -324 M
0 -13 R
(elements in each dimension of the 3D volume array. The return value is a result code \(type )S
FF 17 SF
(vpResult)S
RF 17 SF
(, which is an)S
0 -343 M
0 -13 R
(integer\). The value VP_OK means the arguments are valid and the routine completed successfully. Other values)S
0 -362 M
0 -13 R
(indicate the type of error which occurred. See the man pages for the specific types of errors which can occur for each)S
0 -381 M
0 -13 R
(routine, or see the list of error codes in the )S
(Result Codes and Error Handling)S
( section. )S
0 -400 M
0 -417 M
0 -13 R
(Use )S
FF 17 SF
(vpSetVoxelSize\(\))S
RF 17 SF
( to declare the size of the voxel and the number of fields it contains: )S
0 -436 M
0 -453 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -468 M
0 -10 R
(    vpSetVoxelSize\(vpContext *vpc, int bytes_per_voxel,)S
0 -483 M
0 -10 R
(                   int num_voxel_fields, int num_shade_fields,)S
0 -498 M
0 -10 R
(                   int num_classify_fields\);)S
0 -513 M
0 -530 M
FF 17 SF
0 -13 R
(Bytes_per_voxel)S
RF 17 SF
( is the total size of a voxel in bytes. )S
FF 17 SF
(Num_voxel_fields)S
RF 17 SF
( is the number of fields in the)S
0 -549 M
0 -13 R
(voxel. )S
FF 17 SF
(Num_shade_fields)S
RF 17 SF
( is the number of fields required for shading. )S
FF 17 SF
(Num_classify_fields)S
RF 17 SF
( is the)S
0 -568 M
0 -13 R
(number of fields required for classification. The return value is a result code. )S
0 -587 M
0 -604 M
0 -13 R
(Continuing the earlier example, use the following call: )S
0 -623 M
0 -640 M
FF 14 SF
0 -10 R
(    #define NUM_FIELDS          3)S
0 -655 M
0 -10 R
(    #define NUM_SHADE_FIELDS    2)S
0 -670 M
0 -10 R
(    #define NUM_CLASSIFY_FIELDS 2)S
0 -685 M
0 -10 R
(    vpSetVoxelSize\(vpc, sizeof\(Voxel\), NUM_FIELDS, NUM_SHADE_FIELDS,)S
0 -700 M
0 -10 R
(                   NUM_CLASSIFY_FIELDS\);)S
0 -715 M
0 -732 M
RF 17 SF
0 -13 R
(Now call )S
FF 17 SF
(vpSetVoxelField\(\))S
RF 17 SF
( and the )S
FF 17 SF
(vpFieldOffset\(\))S
RF 17 SF
( macro once for each field to declare its size and)S
0 -751 M
0 -13 R
(position in the voxel: )S
0 -770 M
0 -787 M
FF 14 SF
0 -10 R
(    int)S
0 -802 M
0 -10 R
(    vpFieldOffset\(void *voxel_ptr, field_name\);)S
0 -817 M
0 -832 M
0 -10 R
(    vpResult)S
0 -847 M
0 -10 R
(    vpSetVoxelField\(vpContext *vpc, int field_num, int field_size,)S
0 -862 M
0 -10 R
(                    int field_offset, int field_max\);)S
0 -877 M
0 -894 M
FF 17 SF
0 -13 R
(Voxel_ptr)S
RF 17 SF
( is a pointer to a dummy variable of the same type as your voxel, and )S
FF 17 SF
(field_name)S
RF 17 SF
( is the name of the)S
0 -913 M
0 -13 R
(voxel field. The return value of the macro is the byte offset of the field from the beginning of the voxel. )S
0 -932 M
FF 17 SF
0 -13 R
(Field_num)S
RF 17 SF
( is the ordinal index of the voxel field you are declaring, starting with 0 for the first field. )S
0 -951 M
FF 17 SF
0 -13 R
(Field_size)S
RF 17 SF
( is the size of the field in bytes. Use the )S
FF 17 SF
(sizeof\(\))S
RF 17 SF
( operator \(e.g. )S
0 -970 M
FF 17 SF
0 -13 R
(sizeof\(voxel_ptr->field_name\))S
RF 17 SF
(\). )S
FF 17 SF
(Field_offset)S
RF 17 SF
( is the byte offset returned by )S
0 -989 M
FF 17 SF
0 -13 R
(vpFieldOffset\(\))S
RF 17 SF
(. )S
FF 17 SF
(Field_max)S
RF 17 SF
( is the maximum value of the quantity stored in the field. The return value is a)S
0 -1008 M
0 -13 R
(result code. )S
0 -1027 M
0 -1044 M
0 -13 R
(Strictly speaking, the )S
FF 17 SF
(vpSetVoxelField\(\))S
RF 17 SF
( procedure must be called only for voxel fields which will be used by)S
0 -1063 M
0 -13 R
(the VolPack classifier and shader. However, if you declare the other fields too then VolPack can automatically)S
0 -1082 M
0 -13 R
(convert volumes that were created on machines with a different byte ordering. Only fields with size 1, 2 or 4 bytes)S
0 -1101 M
0 -13 R
(can be declared with )S
FF 17 SF
(vpSetVoxelField\(\))S
RF 17 SF
(. )S
0 -1120 M
0 -1137 M
0 -13 R
(For the example voxel layout, make the following calls: )S
0 -1156 M
0 -1173 M
FF 14 SF
0 -10 R
(    #define NORM_FIELD  0)S
0 -1188 M
0 -10 R
(    #define NORM_MAX    VP_NORM_MAX)S
0 -1203 M
0 -10 R
(    #define SCALAR_FIELD  1)S
showpage restore
%%Page: 5 5
save
NP
FF 14 SF
0 0 M
0 -10 R
(    #define SCALAR_MAX    255)S
0 -15 M
0 -10 R
(    #define GRAD_FIELD    2)S
0 -30 M
0 -10 R
(    #define GRAD_MAX      VP_GRAD_MAX)S
0 -45 M
0 -10 R
(    Voxel *dummy_voxel;)S
0 -60 M
0 -10 R
(    vpSetVoxelField\(vpc, NORM_FIELD, sizeof\(dummy_voxel->normal\),)S
0 -75 M
0 -10 R
(                    vpFieldOffset\(dummy_voxel, normal\), NORM_MAX\);)S
0 -90 M
0 -10 R
(    vpSetVoxelField\(vpc, SCALAR_FIELD, sizeof\(dummy_voxel->scalar\),)S
0 -105 M
0 -10 R
(                    vpFieldOffset\(dummy_voxel, scalar\), SCALAR_MAX\);)S
0 -120 M
0 -10 R
(    vpSetVoxelField\(vpc, GRAD_FIELD, sizeof\(dummy_voxel->gradient\),)S
0 -135 M
0 -10 R
(                    vpFieldOffset\(dummy_voxel, gradient\), GRAD_MAX\);)S
0 -150 M
0 -167 M
RF 17 SF
0 -13 R
(The constants )S
FF 17 SF
(VP_NORM_MAX)S
RF 17 SF
( and )S
FF 17 SF
(VP_GRAD_MAX)S
RF 17 SF
( are predefined by VolPack. In this example these fields will be)S
0 -186 M
0 -13 R
(computed using standard routines provided by the library. )S
0 -205 M
0 -222 M
0 -13 R
(To specify the volume data itself, use )S
FF 17 SF
(SetRawVoxels\(\))S
RF 17 SF
(: )S
0 -241 M
0 -258 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -273 M
0 -10 R
(    vpSetRawVoxels\(vpContext *vpc, void *voxels, int size,)S
0 -288 M
0 -10 R
(                   int xstride, int ystride, int zstride\);)S
0 -303 M
0 -320 M
FF 17 SF
0 -13 R
(Voxels)S
RF 17 SF
( is a pointer to the voxel data. )S
FF 17 SF
(Size)S
RF 17 SF
( is the number of bytes of voxel data. The remaining arguments are the)S
0 -339 M
0 -13 R
(strides in bytes for each of the three dimensions of the volume. For instance, )S
FF 17 SF
(xstride)S
RF 17 SF
( is the byte offset from the)S
0 -358 M
0 -13 R
(beginning of one voxel to the beginning of the next voxel along the x axis. Some of the VolPack routines operate)S
0 -377 M
0 -13 R
(faster if the volume is stored in z-major order \(xstride < ystride < zstride\), but it is not strictly necessary. If )S
0 -396 M
FF 17 SF
0 -13 R
(voxels)S
RF 17 SF
( is a pointer to dynamically allocated storage then the caller is responsible for freeing the memory at the)S
0 -415 M
0 -13 R
(appropriate time. VolPack does not free the voxel array when a context is destroyed. The data in the voxel array may)S
0 -434 M
0 -13 R
(be initialized or modified at any time, before or after calling )S
FF 17 SF
(vpSetRawVoxels)S
RF 17 SF
(. )S
0 -453 M
0 -470 M
0 -13 R
(Our running example continues as follows: )S
0 -489 M
0 -506 M
FF 14 SF
0 -10 R
(    Voxel *volume;)S
0 -521 M
0 -10 R
(    unsigned size;)S
0 -536 M
0 -10 R
(    #define VOLUME_XLEN    256)S
0 -551 M
0 -10 R
(    #define VOLUME_YLEN    256)S
0 -566 M
0 -10 R
(    #define VOLUME_ZLEN    256)S
0 -581 M
0 -10 R
(    size = VOLUME_XLEN * VOLUME_YLEN * VOLUME_ZLEN * sizeof\(Voxel\);)S
0 -596 M
0 -10 R
(    volume = malloc\(size\);)S
0 -611 M
0 -10 R
(    vpSetRawVoxels\(vpc, volume, size, sizeof\(Voxel\),)S
0 -626 M
0 -10 R
(                   VOLUME_XLEN * sizeof\(Voxel\),)S
0 -641 M
0 -10 R
(                   VOLUME_YLEN * VOLUME_XLEN * sizeof\(Voxel\)\);)S
0 -656 M
0 -673 M
RF 17 SF
0 -13 R
(VolPack provides a number of routines to help initialize some of the fields of the volume. If your input data consists)S
0 -692 M
0 -13 R
(of a three-dimensional array of 8-bit values and you wish to compute gradient-magnitude data or encoded normal)S
0 -711 M
0 -13 R
(vectors, then you can use )S
FF 17 SF
(vpVolumeNormals\(\))S
RF 17 SF
(: )S
0 -730 M
0 -747 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -762 M
0 -10 R
(    vpVolumeNormals\(vpContext *vpc, unsigned char *scalars,)S
0 -777 M
0 -10 R
(                    int size, int scalar_field,)S
0 -792 M
0 -10 R
(                    int gradient_field, int normal_field\);)S
0 -807 M
0 -824 M
FF 17 SF
0 -13 R
(Scalars)S
RF 17 SF
( is a pointer to the array of 8-bit values. )S
FF 17 SF
(Size)S
RF 17 SF
( is the size of the array in bytes. It must equal the number)S
0 -843 M
0 -13 R
(of voxels in the volume as previously specified with )S
FF 17 SF
(vpSetVolumeSize\(\))S
RF 17 SF
(. )S
FF 17 SF
(Scalar_field)S
RF 17 SF
(, )S
0 -862 M
FF 17 SF
0 -13 R
(gradient_field)S
RF 17 SF
( and )S
FF 17 SF
(normal_field)S
RF 17 SF
( are the voxel field numbers in which to store the scalar values from the)S
0 -881 M
0 -13 R
(array, the gradient-magnitudes of the scalar values, and the encoded surface normals respectively. Any of these field)S
0 -900 M
0 -13 R
(numbers may be equal to the constant )S
FF 17 SF
(VP_SKIP_FIELD)S
RF 17 SF
( if that item should not be stored in the volume. This)S
0 -919 M
0 -13 R
(function computes the specified fields and loads them into the volume array last specified with )S
0 -938 M
FF 17 SF
0 -13 R
(vpSetRawVolume\(\))S
RF 17 SF
(. )S
0 -957 M
0 -974 M
0 -13 R
(In our example, we can initialize the volume array as follows: )S
0 -993 M
0 -1010 M
FF 14 SF
0 -10 R
(    unsigned char *scalars;)S
0 -1025 M
0 -10 R
(    scalars = LoadScalarData\(\);)S
0 -1040 M
0 -10 R
(    vpVolumeNormals\(vpc, scalars, VOLUME_XLEN*VOLUME_YLEN*VOLUME_ZLEN,)S
0 -1055 M
0 -10 R
(                    SCALAR_FIELD, GRAD_FIELD, NORM_FIELD\);)S
0 -1070 M
0 -1087 M
FF 17 SF
0 -13 R
(LoadScalarData\(\))S
RF 17 SF
( might be a routine to load volume data from a file. )S
0 -1106 M
0 -1123 M
0 -13 R
(If your volume is large it may be inefficient to load all of the scalar data into one array and then copy it to the)S
0 -1142 M
0 -13 R
(volume array. If this is the case then you can use )S
FF 17 SF
(vpScanlineNormals\(\))S
RF 17 SF
( to compute one scanline of the volume)S
0 -1161 M
0 -13 R
(at a time: )S
0 -1180 M
0 -1197 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -1212 M
0 -10 R
(    vpScanlineNormals\(vpContext *vpc, int size,)S
showpage restore
%%Page: 6 6
save
NP
FF 14 SF
0 0 M
0 -10 R
(                      unsigned char *scalars,)S
0 -15 M
0 -10 R
(                      unsigned char *scalars_minus_y,)S
0 -30 M
0 -10 R
(                      unsigned char *scalars_plus_y,)S
0 -45 M
0 -10 R
(                      unsigned char *scalars_minus_z,)S
0 -60 M
0 -10 R
(                      unsigned char *scalars_plus_z,)S
0 -75 M
0 -10 R
(                      void *voxel_scan, int scalar_field,)S
0 -90 M
0 -10 R
(                      int gradient_field, int normal_field\);)S
0 -105 M
0 -122 M
FF 17 SF
0 -13 R
(Size)S
RF 17 SF
( is the length in bytes of one scanline of scalar data \(which should equal the x dimension of the volume\). )S
0 -141 M
FF 17 SF
0 -13 R
(Scalars)S
RF 17 SF
( points to the beginning of one scanline of scalars. )S
FF 17 SF
(Scalars_minus_y)S
RF 17 SF
( and )S
FF 17 SF
(scalars_plus_y)S
RF 17 SF
( point)S
0 -160 M
0 -13 R
(to the beginning of the previous and next scanlines in the y dimension, respectively. Similarly, )S
0 -179 M
FF 17 SF
0 -13 R
(scalars_minus_z)S
RF 17 SF
( and )S
FF 17 SF
(scalars_plus_z)S
RF 17 SF
( point to the beginning of the previous and next scanlines in the z)S
0 -198 M
0 -13 R
(dimension. These last four scanlines are the immediately-adjacent neighbors of the first scanline and are used to)S
0 -217 M
0 -13 R
(compute the gradient and surface normal vector. The next argument, )S
FF 17 SF
(voxel_scan)S
RF 17 SF
(, points to the scanline of the)S
0 -236 M
0 -13 R
(voxel array to write the result data into. The last three arguments are the voxel fields to write each type of data into)S
0 -255 M
0 -13 R
(and are identical to the corresponding arguments to )S
FF 17 SF
(vpVolumeNormals\(\))S
RF 17 SF
(. You can use )S
0 -274 M
FF 17 SF
0 -13 R
(vpScanlineNormals\(\))S
RF 17 SF
( in a loop which reads in the scalar data slice-by-slice, keeping at most three slices of)S
0 -293 M
0 -13 R
(data in memory at a time \(in addition to the entire volume\). )S
0 -312 M
0 -329 M
0 -13 R
(If you wish to compute normal vectors yourself but you still want to use the shading routines provided by VolPack,)S
0 -348 M
0 -13 R
(you can use )S
FF 17 SF
(vpNormalIndex\(\))S
RF 17 SF
( to encode a vector into the form expected by the shaders: )S
0 -367 M
0 -384 M
FF 14 SF
0 -10 R
(    int vpNormalIndex\(double nx, double ny, double nz\);)S
0 -399 M
0 -416 M
RF 17 SF
0 -13 R
(The arguments are the components of the normal vector, which must be normalized \(nx*nx + ny*ny + nz*nz == 1\),)S
0 -435 M
0 -13 R
(and the return value is the 16-bit encoded normal. A routine is also provided to decode normals: )S
0 -454 M
0 -471 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -486 M
0 -10 R
(    vpNormal\(int n, double *nx, double *ny, double *nz\);)S
0 -501 M
0 -518 M
RF 17 SF
0 -13 R
(The encoded normal given by )S
FF 17 SF
(n)S
RF 17 SF
( is decoded, and the normal vector components are stored in the locations specified)S
0 -537 M
0 -13 R
(by the remaining arguments. )S
0 -556 M
0 -573 M
BF 17 SF
0 -14 R
(Classification )S
0 -593 M
0 -610 M
RF 17 SF
0 -13 R
(The classification routines provided by VolPack allow you to customize the opacity transfer function by specifying a)S
0 -629 M
0 -13 R
(collection of lookup tables. Each lookup table is associated with one voxel field. To classify a voxel, VolPack uses)S
0 -648 M
0 -13 R
(the value in each of the specified fields of the voxel to index the corresponding tables. The table values are then)S
0 -667 M
0 -13 R
(multiplied together to get the opacity of the voxel. The tables should contain numbers in the range 0.0-1.0 so that the)S
0 -686 M
0 -13 R
(final opacity is also in that range. )S
0 -705 M
0 -722 M
0 -13 R
(A lookup table is specified with )S
FF 17 SF
(vpSetClassifierTable\(\))S
RF 17 SF
(: )S
0 -741 M
0 -758 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -773 M
0 -10 R
(    vpSetClassifierTable\(vpContext *vpc, int param_num, int param_field,)S
0 -788 M
0 -10 R
(                         float *table, int table_size\);)S
0 -803 M
0 -820 M
FF 17 SF
0 -13 R
(Param_num)S
RF 17 SF
( is the parameter number associated with the table you are declaring. The total number of tables must)S
0 -839 M
0 -13 R
(equal the )S
FF 17 SF
(num_classify_fields)S
RF 17 SF
( argument to )S
FF 17 SF
(vpSetVoxelSize\(\))S
RF 17 SF
(. The first table is numbered 0. )S
0 -858 M
FF 17 SF
0 -13 R
(Param_field)S
RF 17 SF
( is the number of the voxel field which should be used to index the table. )S
FF 17 SF
(Table)S
RF 17 SF
( is a pointer to the)S
0 -877 M
0 -13 R
(lookup table itself, and )S
FF 17 SF
(table_size)S
RF 17 SF
( is the size of the table in bytes \(not the number of entries!\) Note that even if )S
0 -896 M
FF 17 SF
0 -13 R
(table)S
RF 17 SF
( is dynamically allocated it is never deallocated by VolPack, even if the rendering context is destroyed. The)S
0 -915 M
0 -13 R
(data in the table may be initialized or modified at any time, before or after calling )S
FF 17 SF
(vpSetClassifierTable)S
RF 17 SF
(. )S
0 -934 M
0 -951 M
0 -13 R
(We could declare a two-parameter classifier for our example using the following calls: )S
0 -970 M
0 -987 M
FF 14 SF
0 -10 R
(    float scalar_table[SCALAR_MAX+1];)S
0 -1002 M
0 -10 R
(    float gradient_table[GRAD_MAX+1];)S
0 -1017 M
0 -10 R
(    vpSetClassifierTable\(vpc, 0, SCALAR_FIELD, scalar_table,)S
0 -1032 M
0 -10 R
(                         sizeof\(scalar_table\)\);)S
0 -1047 M
0 -10 R
(    vpSetClassifierTable\(vpc, 0, GRAD_FIELD, gradient_table,)S
0 -1062 M
0 -10 R
(                         sizeof\(gradient_table\)\);)S
0 -1077 M
0 -1094 M
RF 17 SF
0 -13 R
(VolPack provides a useful utility routine for initializing classification tables with piecewise linear ramps: )S
0 -1113 M
0 -1130 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -1145 M
0 -10 R
(    vpRamp\(float array[], int stride, int num_points,)S
0 -1160 M
0 -10 R
(           int ramp_x[], float ramp_y[]\);)S
0 -1175 M
0 -1192 M
FF 17 SF
0 -13 R
(Array)S
RF 17 SF
( is the table to be initialized. )S
FF 17 SF
(Stride)S
RF 17 SF
( is the number of bytes from the start of one array element to the start)S
0 -1211 M
0 -13 R
(of the next \(useful if there are other fields in the array which you want to skip over\). )S
FF 17 SF
(Num_points)S
RF 17 SF
( is the number)S
showpage restore
%%Page: 7 7
save
NP
RF 17 SF
0 0 M
0 -13 R
(of endpoints of the piecewise linear segments. )S
FF 17 SF
(Ramp_x)S
RF 17 SF
( is an array of x coordinates \(table indices\), and )S
FF 17 SF
(ramp_y)S
RF 17 SF
( is)S
0 -19 M
0 -13 R
(an array of y coordinates \(values to store in the array\). )S
FF 17 SF
(vpRamp)S
RF 17 SF
( linearly-interpolates values for the table entries in)S
0 -38 M
0 -13 R
(between the specified x coordinates. )S
0 -57 M
0 -74 M
0 -13 R
(For example, we can initialize our two classification tables as follows: )S
0 -93 M
0 -110 M
FF 14 SF
0 -10 R
(    #define SCALAR_RAMP_POINTS 3)S
0 -125 M
0 -10 R
(    int scalar_ramp_x[] =    {  0,  24, 255};)S
0 -140 M
0 -10 R
(    float scalar_ramp_y[] =  {0.0, 1.0, 1.0};)S
0 -155 M
0 -10 R
(    vpRamp\(scalar_table, sizeof\(float\), SCALAR_RAMP_POINTS,)S
0 -170 M
0 -10 R
(           scalar_ramp_x, scalar_ramp_y\);)S
0 -185 M
0 -200 M
0 -10 R
(    #define GRAD_RAMP_POINTS 4)S
0 -215 M
0 -10 R
(    int grad_ramp_x[] =   {  0,   5,  20, 221};)S
0 -230 M
0 -10 R
(    float grad_ramp_y[] = {0.0, 0.0, 1.0, 1.0};)S
0 -245 M
0 -10 R
(    vpRamp\(gradient_table, sizeof\(float\), GRAD_RAMP_POINTS,)S
0 -260 M
0 -10 R
(           grad_ramp_x, grad_ramp_y\);)S
0 -275 M
0 -292 M
RF 17 SF
0 -13 R
(If you wish to use an alternative classification algorithm instead of the lookup-table classifier then you should store)S
0 -311 M
0 -13 R
(the voxel opacities you compute in one of the fields of the voxel and define a lookup table which converts the values)S
0 -330 M
0 -13 R
(in that field into floating-point numbers. For instance, define a 1-byte opacity field which contains values in the)S
0 -349 M
0 -13 R
(range 0-255, and declare a lookup table with a linear ramp mapping those numbers to the range 0.0-1.0. )S
0 -368 M
0 -385 M
0 -13 R
(In addition to setting the classification function, you should also set the minimum opacity threshold with )S
FF 17 SF
(vpSeti)S
RF 17 SF
(.)S
0 -404 M
0 -13 R
(This threshold is used to discard voxels which are so transparent that they do not contribute significantly to the)S
0 -423 M
0 -13 R
(image. The higher the threshold, the faster the rendering algorithms. For example, to discard voxels which are at)S
0 -442 M
0 -13 R
(most 5% opaque, use the following: )S
0 -461 M
0 -478 M
FF 14 SF
0 -10 R
(    vpSeti\(vpc, VP_MIN_VOXEL_OPACITY, 0.05\);)S
0 -493 M
0 -510 M
BF 17 SF
0 -14 R
(Classified Volumes )S
0 -530 M
0 -547 M
RF 17 SF
0 -13 R
(The fastest rendering algorithm provided by VolPack uses a run-length encoded volume data structure which must)S
0 -566 M
0 -13 R
(be computed before rendering. Three routines are provided to compute this data structure. Remember to set the)S
0 -585 M
0 -13 R
(opacity transfer function and the minimum voxel opacity before calling the functions in this subsection. )S
0 -604 M
0 -621 M
0 -13 R
(If you have already constructed an unclassified volume and defined the classification function as described in the)S
0 -640 M
0 -13 R
(previous subsections then use )S
FF 17 SF
(vpClassifyVolume\(\))S
RF 17 SF
(: )S
0 -659 M
0 -676 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -691 M
0 -10 R
(    vpClassifyVolume\(vpContext *vpc\);)S
0 -706 M
0 -723 M
RF 17 SF
0 -13 R
(This routine reads data from the currently-defined volume array, classifies it using the current classifier, and then)S
0 -742 M
0 -13 R
(stores it in run-length encoded form in the rendering context. The volume array is not modified or deallocated. )S
0 -761 M
0 -778 M
0 -13 R
(If you wish to load an array of 8-bit scalars and compute a classified volume directly without building an)S
0 -797 M
0 -13 R
(unclassified volume, then use )S
FF 17 SF
(vpClassifyScalars\(\))S
RF 17 SF
(: )S
0 -816 M
0 -833 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -848 M
0 -10 R
(    vpClassifyScalars\(vpContext *vpc, unsigned char *scalars,)S
0 -863 M
0 -10 R
(                      int size, int scalar_field,)S
0 -878 M
0 -10 R
(                      int gradient_field, int normal_field\);)S
0 -893 M
0 -910 M
RF 17 SF
0 -13 R
(The arguments to this routine are identical to those for )S
FF 17 SF
(vpVolumeNormals\(\))S
RF 17 SF
( described above. The difference)S
0 -929 M
0 -13 R
(between the two routines is that )S
FF 17 SF
(vpClassifyScalars\(\))S
RF 17 SF
( stores the result as a classified, run-length encoded)S
0 -948 M
0 -13 R
(volume instead of as an unclassified volume. The volume size, voxel size, voxel fields, and classifier must all be)S
0 -967 M
0 -13 R
(declared before calling this routine, but there is no need to call )S
FF 17 SF
(vpSetRawVoxels\(\))S
RF 17 SF
(. )S
0 -986 M
0 -1003 M
0 -13 R
(If you wish to classify one scanline of voxel data at a time instead of loading the entire array of scalar data at once)S
0 -1022 M
0 -13 R
(then use )S
FF 17 SF
(vpClassifyScanline\(\))S
RF 17 SF
(: )S
0 -1041 M
0 -1058 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -1073 M
0 -10 R
(    vpClassifyScanline\(vpContext *vpc, void *voxel_scan\);)S
0 -1088 M
0 -1105 M
FF 17 SF
0 -13 R
(Voxel_scan)S
RF 17 SF
( is a pointer to one scanline of voxel data, in the same format as the full unclassified volume. You)S
0 -1124 M
0 -13 R
(could, for instance, use )S
FF 17 SF
(vpScanlineNormals\(\))S
RF 17 SF
( to compute the fields of the scanline before passing it to )S
0 -1143 M
FF 17 SF
0 -13 R
(vpClassifyScanline\(\))S
RF 17 SF
(. Each call to this routine appends one new scanline to the current classified volume.)S
0 -1162 M
0 -13 R
(Out-of-order calls are not possible, and the volume cannot be rendered until all of the scanlines have been loaded. )S
0 -1181 M
0 -1198 M
0 -13 R
(Only one classified volume may be stored in a rendering context at a time. If you start classifying a new volume, any)S
showpage restore
%%Page: 8 8
save
NP
RF 17 SF
0 0 M
0 -13 R
(old classified volume data is deallocated. You can also force the current classified volume to be deallocated with )S
0 -19 M
FF 17 SF
0 -13 R
(vpDestroyClassifiedVolume\(\))S
RF 17 SF
(: )S
0 -38 M
0 -55 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -70 M
0 -10 R
(    vpDestroyClassifiedVolume\(vpContext *vpc\);)S
0 -85 M
0 -102 M
RF 17 SF
0 -13 R
(Note that if you change the contents of the unclassified volume array and you wish the classified volume to reflect)S
0 -121 M
0 -13 R
(those changes then you must call one of the routines in this section to recompute the classified volume. )S
0 -140 M
0 -157 M
BF 17 SF
0 -14 R
(Min-Max Octrees )S
0 -177 M
0 -194 M
RF 17 SF
0 -13 R
(A min-max octree is a hierarchical data structure which contains minimum and maximum values for each field used)S
0 -213 M
0 -13 R
(to index the classification tables. This data structure can be used to accelerate rendering unclassified volumes, and it)S
0 -232 M
0 -13 R
(can also accelerate the computation of a classified volume from an unclassified volume. )S
0 -251 M
0 -268 M
0 -13 R
(To compute a min-max octree, first define an unclassified volume with )S
FF 17 SF
(vpSetVolumeSize\(\))S
RF 17 SF
(, )S
0 -287 M
FF 17 SF
0 -13 R
(vpSetVoxelSize\(\))S
RF 17 SF
(, )S
FF 17 SF
(vpSetVoxelField\(\))S
RF 17 SF
(, and )S
FF 17 SF
(vpSetRawVoxels\(\))S
RF 17 SF
(. Also be sure to initialize the)S
0 -306 M
0 -13 R
(volume data. Now for each classification table make one call to )S
FF 17 SF
(vpMinMaxOctreeThreshold\(\))S
RF 17 SF
(: )S
0 -325 M
0 -342 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -357 M
0 -10 R
(    vpMinMaxOctreeThreshold\(vpContext *vpc, int param_num, int range\);)S
0 -372 M
0 -389 M
FF 17 SF
0 -13 R
(Param_num)S
RF 17 SF
( is the same parameter number you passed to )S
FF 17 SF
(vpSetClassifierTable\(\))S
RF 17 SF
(. )S
FF 17 SF
(Range)S
RF 17 SF
( is a range of)S
0 -408 M
0 -13 R
(table indices for this parameter which you consider to be "small". The opacity of a voxel should not vary much if the)S
0 -427 M
0 -13 R
(table index is changed by the amount specified in )S
FF 17 SF
(range)S
RF 17 SF
(. Choosing a value which is too small or too large may)S
0 -446 M
0 -13 R
(result in a reduced performance benefit during rendering. You may wish to experiment, but the octree should)S
0 -465 M
0 -13 R
(improve performance even if you don't use the optimum range value. You can use the routine )S
FF 17 SF
(vpOctreeMask\(\))S
0 -484 M
RF 17 SF
0 -13 R
(to visualize the effectiveness of the octree \(see the man pages\). )S
0 -503 M
0 -520 M
0 -13 R
(To compute the octree, call )S
FF 17 SF
(vpCreateMinMaxOctree\(\))S
RF 17 SF
(: )S
0 -539 M
0 -556 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -571 M
0 -10 R
(    vpCreateMinMaxOctree\(vpContext *vpc, int root_node_size,)S
0 -586 M
0 -10 R
(                         int base_node_size\);)S
0 -601 M
0 -618 M
FF 17 SF
0 -13 R
(Root_node_size)S
RF 17 SF
( is currently not used but is reserved for future use. )S
FF 17 SF
(Base_node_size)S
RF 17 SF
( specifies the size in)S
0 -637 M
0 -13 R
(voxels of one side of the smallest node in the octree. The smaller the value, the better the resolution of the data)S
0 -656 M
0 -13 R
(structure at the expense of an increase in size. A value of 4 is a good starting point. This routine reads the data in the)S
0 -675 M
0 -13 R
(unclassified volume array, computes an octree, and stores it in the rendering context. )S
0 -694 M
0 -711 M
0 -13 R
(Once the octree has been computed it will be used automatically whenever you call )S
FF 17 SF
(vpClassifyVolume\(\))S
RF 17 SF
( or )S
0 -730 M
FF 17 SF
0 -13 R
(vpRenderRawVolume\(\))S
RF 17 SF
(. If you change the data in the volume array you MUST call )S
0 -749 M
FF 17 SF
0 -13 R
(vpCreateMinMaxOctree)S
RF 17 SF
( to recompute the octree, or else your renderings will be incorrect. You can also)S
0 -768 M
0 -13 R
(destroy the octree by calling )S
FF 17 SF
(vpDestroyMinMaxOctree\(\))S
RF 17 SF
(: )S
0 -787 M
0 -804 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -819 M
0 -10 R
(    vpDestroyMinMaxOctree\(vpContext *vpc\);)S
0 -834 M
0 -851 M
BF 17 SF
0 -14 R
(View Transformations )S
0 -871 M
0 -888 M
RF 17 SF
0 -13 R
(VolPack maintains four transformation matrices: a modeling transform, a viewing transform, a projection)S
0 -907 M
0 -13 R
(transform, and a viewport transform. The primary use of these matrices is to specify a transformation from the)S
0 -926 M
0 -13 R
(volume data's coordinate system to the image coordinate system. However, they also affect light direction vectors)S
0 -945 M
0 -13 R
(\(and in future releases of the library they will affect the positioning of clipping planes and polygon primitives\). )S
0 -964 M
0 -981 M
0 -13 R
(There are five coordinate systems implied by the transformation matrices: object coordinates, world coordinates, eye)S
0 -1000 M
0 -13 R
(coordinates, clip coordinates, and image coordinates. In the object coordinate system the volume is entirely contained)S
0 -1019 M
0 -13 R
(in a unit cube centered at the origin. The modeling transform is an affine transform which converts object)S
0 -1038 M
0 -13 R
(coordinates into world coordinates. The modeling transform is also applied to light direction vectors to transform)S
0 -1057 M
0 -13 R
(them to world coordinates. The view transform is an affine transform that converts world coordinates into eye)S
0 -1076 M
0 -13 R
(coordinates. In eye coordinates the viewer is looking down the -Z axis. The view transform is typically used to)S
0 -1095 M
0 -13 R
(specify the position of the viewer in the world coordinate system. The projection transform converts eye coordinates)S
0 -1114 M
0 -13 R
(into clip coordinates. This transform may specify a perspective or a parallel projection, although perspective)S
0 -1133 M
0 -13 R
(rendering is not yet supported. Finally, the viewport transform converts the clip coordinate system into image)S
0 -1152 M
0 -13 R
(coordinates. )S
0 -1171 M
0 -1188 M
0 -13 R
(VolPack provides a number of routines to change the modeling matrix, viewing matrix and the projection matrix.)S
0 -1207 M
0 -13 R
(First, use )S
FF 17 SF
(vpCurrentMatrix\(\))S
RF 17 SF
( to select the matrix you wish to modify: )S
showpage restore
%%Page: 9 9
save
NP
RF 17 SF
0 0 M
0 -17 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -32 M
0 -10 R
(    vpCurrentMatrix\(vpContext *vpc, int option\);)S
0 -47 M
0 -64 M
FF 17 SF
0 -13 R
(Option)S
RF 17 SF
( is one of the constants )S
FF 17 SF
(VP_MODEL)S
RF 17 SF
(, )S
FF 17 SF
(VP_VIEW)S
RF 17 SF
( or )S
FF 17 SF
(VP_PROJECT)S
RF 17 SF
(. Now use the following functions to)S
0 -83 M
0 -13 R
(modify the matrix contents \(see the man pages for specifics\): )S
0 -102 M
0 -119 M
FF 17 SF
0 -13 R
(vpIdentityMatrix\(vpContext *vpc\))S
RF 17 SF
( )S
48 -138 M
0 -13 R
(Load the identity matrix into the current transformation matrix. )S
0 -157 M
FF 17 SF
0 -13 R
(vpTranslate\(vpContext *vpc, double tx, double ty, double tz\))S
RF 17 SF
( )S
48 -176 M
0 -13 R
(Multiply the current transformation matrix by a translation matrix. )S
0 -195 M
FF 17 SF
0 -13 R
(vpRotate\(vpContext *vpc, int axis, double degrees\))S
RF 17 SF
( )S
48 -214 M
0 -13 R
(Multiply the current transformation matrix by a rotation matrix. )S
FF 17 SF
(Axis)S
RF 17 SF
( is one of the constants )S
FF 17 SF
(VP_X_AXIS)S
RF 17 SF
(, )S
48 -233 M
FF 17 SF
0 -13 R
(VP_Y_AXIS)S
RF 17 SF
( or )S
FF 17 SF
(VP_Z_AXIS)S
RF 17 SF
(. )S
0 -252 M
FF 17 SF
0 -13 R
(vpScale\(vpContext *vpc, double sx, double sy, double sz\))S
RF 17 SF
( )S
48 -271 M
0 -13 R
(Multiply the current transformation matrix by a scaling matrix. )S
0 -290 M
FF 17 SF
0 -13 R
(vpMultMatrix\(vpContext *vpc, vpMatrix4 m\))S
RF 17 SF
( )S
48 -309 M
0 -13 R
(Multiply the current transformation matrix by the given matrix. )S
0 -328 M
FF 17 SF
0 -13 R
(vpSetMatrix\(vpContext *vpc, vpMatrix4 m\))S
RF 17 SF
( )S
48 -347 M
0 -13 R
(Load the given matrix into the current transformation matrix. )S
48 -366 M
0 -383 M
0 -13 R
(By default, all of the routines use post-multiplication. For instance, if the current modeling matrix is M and a)S
0 -402 M
0 -13 R
(rotation matrix R is applied, then the new transformation is M*R. If a light direction vector v is now specified)S
0 -421 M
0 -13 R
(\(using commands discussed in the section on shading\), it is transformed into M*R*v before it is stored in the current)S
0 -440 M
0 -13 R
(rendering context. If you prefer pre-multiplication of matrices then call )S
FF 17 SF
(vpSeti)S
RF 17 SF
( with the )S
FF 17 SF
(CONCAT_MODE)S
0 -459 M
RF 17 SF
0 -13 R
(argument. Note that vectors are always post-multiplied. )S
0 -478 M
0 -495 M
0 -13 R
(Two special routines are provided for creating projection matrices. These routines always store their result in the)S
0 -514 M
0 -13 R
(projection matrix, not the current matrix. The first is )S
FF 17 SF
(vpWindow\(\))S
RF 17 SF
(: )S
0 -533 M
0 -550 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -565 M
0 -10 R
(    vpWindow\(vpContext *vpc, int type, double left, double right,)S
0 -580 M
0 -10 R
(             double bottom, double top, double near, double far\);)S
0 -595 M
0 -612 M
FF 17 SF
0 -13 R
(Type)S
RF 17 SF
( must be the constant )S
FF 17 SF
(VP_PARALLEL)S
RF 17 SF
( to specify a parallel projection. In a future release perspective)S
0 -631 M
0 -13 R
(projections will be allowed. The remaining arguments specify the left, right, bottom, top, near, and far coordinates)S
0 -650 M
0 -13 R
(of the planes bounding the view volume in eye coordinates. This routine works just like the )S
FF 17 SF
(glFrustum\(\))S
RF 17 SF
( and )S
0 -669 M
FF 17 SF
0 -13 R
(glOrtho\(\))S
RF 17 SF
( routines in OpenGL. )S
0 -688 M
0 -705 M
0 -13 R
(The second routine for creating a projection matrix uses the PHIGS viewing model: )S
0 -724 M
0 -741 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -756 M
0 -10 R
(    vpWindowPHIGS\(vpContext *vpc, vpVector3 vrp, vpVector3 vpn,)S
0 -771 M
0 -10 R
(             vpVector3 vup, vpVector3 prp, double viewport_umin,)S
0 -786 M
0 -10 R
(             double viewport_umax, double viewport_vmin,)S
0 -801 M
0 -10 R
(             double viewport_vmax, double viewport_front,)S
0 -816 M
0 -10 R
(             double viewport_back, int type\);)S
0 -831 M
0 -848 M
FF 17 SF
0 -13 R
(Vrp)S
RF 17 SF
( is the view reference point, )S
FF 17 SF
(vpn)S
RF 17 SF
( is the view plane normal, )S
FF 17 SF
(vup)S
RF 17 SF
( is the view up vector, )S
FF 17 SF
(prp)S
RF 17 SF
( is the projection)S
0 -867 M
0 -13 R
(reference point, the next six arguments are the bounds of the viewing volume in view reference coordinates, and )S
0 -886 M
FF 17 SF
0 -13 R
(type)S
RF 17 SF
( is the constant )S
FF 17 SF
(VP_PARALLEL)S
RF 17 SF
( to specify a parallel projection. Since these parameters specify a viewpoint as)S
0 -905 M
0 -13 R
(well as a viewing volume, typically the view matrix contains the identity. See )S
IF 17 SF
(Computer Graphics: Principles and)S
0 -924 M
0 -13 R
(Practice)S
RF 17 SF
( \(Chapter 6, 2nd ed.\), by Foley, van Dam, Feiner and Hughes for a complete discussion of the PHIGS)S
0 -943 M
0 -13 R
(viewing model. )S
0 -962 M
0 -979 M
0 -13 R
(The viewport transform is set automatically when you set the size of the image, which is discussed in the next)S
0 -998 M
0 -13 R
(subsection. )S
0 -1017 M
0 -1034 M
0 -13 R
(Here is an example showing all the steps to set the view transformation: )S
0 -1053 M
0 -1070 M
FF 14 SF
0 -10 R
(    vpCurrentMatrix\(vpc, VP_MODEL\);)S
0 -1085 M
0 -10 R
(    vpIdentityMatrix\(vpc\);)S
0 -1100 M
0 -10 R
(    vpRotate\(vpc, VP_X_AXIS, 90.0\);)S
0 -1115 M
0 -10 R
(    vpRotate\(vpc, VP_Y_AXIS, 23.0\);)S
0 -1130 M
0 -10 R
(    vpCurrentMatrix\(vpc, VP_VIEW\);)S
0 -1145 M
0 -10 R
(    vpIdentityMatrix\(vpc\);)S
0 -1160 M
0 -10 R
(    vpTranslate\(vpc, 0.1, 0.0, 0.0\);)S
0 -1175 M
0 -10 R
(    vpCurrentMatrix\(vpc, VP_PROJECT\);)S
0 -1190 M
0 -10 R
(    vpWindow\(vpc, VP_PARALLEL, -0.5, 0.5, -0.5, 0.5, -0.5, 0.5\);)S
0 -1205 M
showpage restore
%%Page: 10 10
save
NP
FF 14 SF
0 0 M
RF 17 SF
0 -13 R
(Note that light direction vectors are transformed according to the modeling matrix in effect at the time of the call to )S
0 -19 M
FF 17 SF
0 -13 R
(vpSetLight)S
RF 17 SF
(, and volumes are transformed according to the modeling matrix in effect at the time of rendering.)S
0 -38 M
0 -13 R
(The same viewing, projection and viewport transforms are applied to everything at the time of rendering. )S
0 -57 M
0 -74 M
BF 17 SF
0 -14 R
(Shading and Lighting )S
0 -94 M
0 -111 M
RF 17 SF
0 -13 R
(VolPack supports two shading methods: shading via lookup tables, and shading via callback functions. In addition,)S
0 -130 M
0 -13 R
(routines are provided to initialize shading tables for the Phong illumination model. )S
0 -149 M
0 -166 M
0 -13 R
(The built-in routines are designed to support the multiple-material voxel model described in )S
IF 17 SF
(Volume Rendering)S
RF 17 SF
( by)S
0 -185 M
0 -13 R
(Drebin, Carpenter and Hanrahan in Proceedings of SIGGRAPH 88. Each voxel is assumed to contain a mixture of)S
0 -204 M
0 -13 R
(basic material types. Each material type has its own shading parameters, such as color and shinyness. The color of a)S
0 -223 M
0 -13 R
(voxel is found by computing a color for each material type and then combining the colors in proportion to the)S
0 -242 M
0 -13 R
(fraction of each material in the voxel. )S
0 -261 M
0 -278 M
0 -13 R
(This functionality is implemented by storing two table indices in each voxel and using two lookup tables. One voxel)S
0 -297 M
0 -13 R
(field must contain an encoded surface normal vector as computed by )S
FF 17 SF
(vpNormalIndex\(\))S
RF 17 SF
(. This field is used to)S
0 -316 M
0 -13 R
(index a table which contains a color for each of the material types. The actual colors retrieved from the table depend)S
0 -335 M
0 -13 R
(on the surface normal, so directional lights can be implemented by storing appropriate values in the table. The)S
0 -354 M
0 -13 R
(second voxel field contains a value which is used to index the second table. Each row of the second table contains a)S
0 -373 M
0 -13 R
(fractional occupancy for each material type. These fractional occupancies are used as weights to determine the)S
0 -392 M
0 -13 R
(relative strength of each color retrieved from the first table. )S
0 -411 M
0 -428 M
0 -13 R
(To declare a lookup-table shader, use )S
FF 17 SF
(vpSetLookupShader\(\))S
RF 17 SF
(: )S
0 -447 M
0 -464 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -479 M
0 -10 R
(    vpSetLookupShader\(vpContext *vpc, int color_channels,)S
0 -494 M
0 -10 R
(                      int num_materials, int color_field,)S
0 -509 M
0 -10 R
(                      float *color_table, int color_table_size,)S
0 -524 M
0 -10 R
(                      int weight_field,)S
0 -539 M
0 -10 R
(                      float *weight_table, int weight_table_size\);)S
0 -554 M
0 -571 M
FF 17 SF
0 -13 R
(Color_channels)S
RF 17 SF
( is 1 for grayscale renderings or 3 for color \(RGB\) renderings. )S
FF 17 SF
(Num_materials)S
RF 17 SF
( is the)S
0 -590 M
0 -13 R
(number of material types. )S
FF 17 SF
(Color_field)S
RF 17 SF
( is the voxel field number for the color lookup table index. )S
0 -609 M
FF 17 SF
0 -13 R
(Color_table)S
RF 17 SF
( is the corresponding lookup table, and )S
FF 17 SF
(color_table_size)S
RF 17 SF
( is the size of the table in bytes. )S
0 -628 M
FF 17 SF
0 -13 R
(Weight_field)S
RF 17 SF
(, )S
FF 17 SF
(weight_table)S
RF 17 SF
( and )S
FF 17 SF
(weight_table_size)S
RF 17 SF
( are the field number, lookup table and table)S
0 -647 M
0 -13 R
(size for the second table which contains weights for each material type. The color table must be an array with the)S
0 -666 M
0 -13 R
(following dimensions: )S
0 -685 M
0 -702 M
FF 14 SF
0 -10 R
(    float color_table[n][num_materials][color_channels];)S
0 -717 M
0 -734 M
RF 17 SF
0 -13 R
(where )S
FF 17 SF
(n)S
RF 17 SF
( is the number of possible values for the color field. The colors are values in the range 0.0-1.0 \(zero)S
0 -753 M
0 -13 R
(intensity to full intensity\). The weight table must be an array with the following dimensions: )S
0 -772 M
0 -789 M
FF 14 SF
0 -10 R
(    float weight_table[m][num_materials];)S
0 -804 M
0 -821 M
RF 17 SF
0 -13 R
(where )S
FF 17 SF
(m)S
RF 17 SF
( is the number of possible values for the weight field. Weights are in the range 0.0-1.0. If there is only one)S
0 -840 M
0 -13 R
(material type then the weight table is not used and the corresponding parameters may be set to 0. )S
0 -859 M
0 -876 M
0 -13 R
(Returning to our example, the following code declares an RGB shader with two material types: )S
0 -895 M
0 -912 M
FF 14 SF
0 -10 R
(    #define COLOR_CHANNELS   3)S
0 -927 M
0 -10 R
(    #define MATERIALS        2)S
0 -942 M
0 -10 R
(    float color_table[NORM_MAX+1][MATERIALS][COLOR_CHANNELS];)S
0 -957 M
0 -10 R
(    float weight_table[SCALAR_MAX+1][MATERIALS];)S
0 -972 M
0 -10 R
(    vpSetLookupShader\(vpc, COLOR_CHANNELS, MATERIALS,)S
0 -987 M
0 -10 R
(                      NORM_FIELD, color_table, sizeof\(color_table\),)S
0 -1002 M
0 -10 R
(                      SCALAR_FIELD, weight_table, sizeof\(weight_table\)\);)S
0 -1017 M
0 -1034 M
RF 17 SF
0 -13 R
(The weight table can be initialized using the )S
FF 17 SF
(vpRamp\(\))S
RF 17 SF
( function previously described, or using a loop which fills)S
0 -1053 M
0 -13 R
(in values in whatever way you choose. To initialize the color table, VolPack provides a routine called )S
0 -1072 M
FF 17 SF
0 -13 R
(vpShadeTable\(\))S
RF 17 SF
(. Before calling the routine you must set the lighting and shading parameters as follows. )S
0 -1091 M
0 -1108 M
0 -13 R
(To set the lighting parameters, use )S
FF 17 SF
(vpSetLight\(\))S
RF 17 SF
(: )S
0 -1127 M
0 -1144 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -1159 M
0 -10 R
(    vpSetLight\(vpContext *vpc, int light_num, int property,)S
0 -1174 M
0 -10 R
(               double n0, double n1, double n2\);)S
0 -1189 M
0 -1206 M
FF 17 SF
0 -13 R
(Light_num)S
RF 17 SF
( is one of the constants )S
FF 17 SF
(VP_LIGHT0)S
RF 17 SF
(, )S
FF 17 SF
(VP_LIGHT1)S
RF 17 SF
(, ..., )S
FF 17 SF
(VP_LIGHT5)S
RF 17 SF
( and indicates which of the six)S
showpage restore
%%Page: 11 11
save
NP
RF 17 SF
0 0 M
0 -13 R
(light sources you wish to adjust. )S
FF 17 SF
(Property)S
RF 17 SF
( is either )S
FF 17 SF
(VP_COLOR)S
RF 17 SF
( or )S
FF 17 SF
(VP_DIRECTION)S
RF 17 SF
(. For )S
FF 17 SF
(VP_COLOR)S
RF 17 SF
( the)S
0 -19 M
0 -13 R
(remaining three arguments are the RGB components of the light color, in the range 0.0-1.0. For )S
FF 17 SF
(VP_DIRECTION)S
0 -38 M
RF 17 SF
0 -13 R
(the remaining three arguments are the x, y and z components of the direction of the light source. This vector is)S
0 -57 M
0 -13 R
(transformed by the current modeling matrix before it is stored in the rendering context \(see )S
(View Transformations)S
(\).)S
0 -76 M
0 -13 R
(You must also call )S
FF 17 SF
(vpEnable\(\))S
RF 17 SF
( to enable the light. By default, light 0 is enabled and all others are disabled. )S
0 -95 M
0 -112 M
0 -13 R
(For example, to create a cyan light coming from above the viewer's right shoulder, use the following: )S
0 -131 M
0 -148 M
FF 14 SF
0 -10 R
(    vpSetLight\(vpc, VP_LIGHT1, VP_COLOR,      0.0,  1.0,  1.0\);)S
0 -163 M
0 -10 R
(    vpSetLight\(vpc, VP_LIGHT1, VP_DIRECTION, -0.6,  0.6,  1.0\);)S
0 -178 M
0 -10 R
(    vpEnable\(vpc, VP_LIGHT1, 1\);)S
0 -193 M
0 -210 M
RF 17 SF
0 -13 R
(You can also select "two-sided" lights using )S
FF 17 SF
(vpEnable\(\))S
RF 17 SF
( with the )S
FF 17 SF
(VP_LIGHT_BOTH_SIDES)S
RF 17 SF
( option. Under)S
0 -229 M
0 -13 R
(this lighting model each directional light shines in two directions, both in the specified direction and in the opposite)S
0 -248 M
0 -13 R
(direction. )S
0 -267 M
0 -284 M
0 -13 R
(To set the material parameters for a particular material type, call )S
FF 17 SF
(vpSetMaterial\(\))S
RF 17 SF
(: )S
0 -303 M
0 -320 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -335 M
0 -10 R
(    vpSetMaterial\(vpContext *vpc, int material_num, int property,)S
0 -350 M
0 -10 R
(                  int surface_side, double r, double g, double b\);)S
0 -365 M
0 -382 M
FF 17 SF
0 -13 R
(Material_num)S
RF 17 SF
( is one of the constants )S
FF 17 SF
(VP_MATERIAL0)S
RF 17 SF
(, )S
FF 17 SF
(VP_MATERIAL1)S
RF 17 SF
(, ..., )S
FF 17 SF
(VP_MATERIAL5)S
RF 17 SF
( and indicates)S
0 -401 M
0 -13 R
(which material you wish to adjust. )S
FF 17 SF
(Property)S
RF 17 SF
( is one of the following: )S
0 -420 M
0 -437 M
FF 17 SF
0 -13 R
(VP_AMBIENT)S
RF 17 SF
( )S
48 -456 M
0 -13 R
(Set the R, G and B ambient light reflection coefficients. )S
0 -475 M
FF 17 SF
0 -13 R
(VP_DIFFUSE)S
RF 17 SF
( )S
48 -494 M
0 -13 R
(Set the R, G and B diffuse light reflection coefficients. )S
0 -513 M
FF 17 SF
0 -13 R
(VP_SPECULAR)S
RF 17 SF
( )S
48 -532 M
0 -13 R
(Set the R, G and B specular light reflection coefficients. )S
0 -551 M
FF 17 SF
0 -13 R
(VP_SHINYNESS)S
RF 17 SF
( )S
48 -570 M
0 -13 R
(Set the specular exponent. The )S
FF 17 SF
(g)S
RF 17 SF
( and )S
FF 17 SF
(b)S
RF 17 SF
( arguments are not used. )S
48 -589 M
0 -606 M
FF 17 SF
0 -13 R
(Surface_side)S
RF 17 SF
( is either )S
FF 17 SF
(VP_EXTERIOR)S
RF 17 SF
(, )S
FF 17 SF
(VP_INTERIOR)S
RF 17 SF
(, or )S
FF 17 SF
(VP_BOTH_SIDES)S
RF 17 SF
(. In the first case the)S
0 -625 M
0 -13 R
(parameters will only affect voxels on the "exterior" side of a surface, which by default means that the voxel's)S
0 -644 M
0 -13 R
(gradient points towards the viewer \(you can use )S
FF 17 SF
(vpEnable\(\))S
RF 17 SF
( with the )S
FF 17 SF
(VP_REVERSE_SURFACE_SIDES)S
RF 17 SF
( option)S
0 -663 M
0 -13 R
(to reverse the meaning of exterior and interior\). In the second case the parameters will only affect voxels whose)S
0 -682 M
0 -13 R
(gradient points away from the viewer. In the third case, all voxels are affected. )S
0 -701 M
0 -718 M
0 -13 R
(Here is an example which sets surface 0 to reflect red and green ambient and diffuse light, and to have fairly strong)S
0 -737 M
0 -13 R
(specular highlights which retain the color of the light source: )S
0 -756 M
0 -773 M
FF 14 SF
0 -10 R
(    vpSetMaterial\(vpc, VP_MATERIAL0, VP_AMBIENT,)S
0 -788 M
0 -10 R
(                  VP_BOTHSIDES, 0.1, 0.1, 0.0\);)S
0 -803 M
0 -10 R
(    vpSetMaterial\(vpc, VP_MATERIAL0, VP_DIFFUSE,)S
0 -818 M
0 -10 R
(                  VP_BOTHSIDES, 0.4, 0.4, 0.0\);)S
0 -833 M
0 -10 R
(    vpSetMaterial\(vpc, VP_MATERIAL0, VP_SPECULAR,)S
0 -848 M
0 -10 R
(                  VP_BOTHSIDES, 0.5, 0.5, 0.5\);)S
0 -863 M
0 -10 R
(    vpSetMaterial\(vpc, VP_MATERIAL0, VP_SHINYNESS,)S
0 -878 M
0 -10 R
(                  VP_BOTHSIDES, 10.0, 0.0, 0.0\);)S
0 -893 M
0 -910 M
RF 17 SF
0 -13 R
(Now that all of the lighting and shading parameters have been set, the color lookup table has been declared with )S
0 -929 M
FF 17 SF
0 -13 R
(vpSetLookupShader\(\))S
RF 17 SF
(, and the viewing parameters have been set, you can call )S
FF 17 SF
(vpShadeTable\(\))S
RF 17 SF
( to)S
0 -948 M
0 -13 R
(recompute the entries of the lookup table: )S
0 -967 M
0 -984 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -999 M
0 -10 R
(    vpShadeTable\(vpContext *vpc\);)S
0 -1014 M
0 -1031 M
RF 17 SF
0 -13 R
(This routine computes all of the entries in the currently-defined color table using the current lighting and material)S
0 -1050 M
0 -13 R
(parameters and the current view transformation. You should call )S
FF 17 SF
(vpShadeTable\(\))S
RF 17 SF
( after any changes to the)S
0 -1069 M
0 -13 R
(shading or viewing parameters, but before calling any of the rendering routines. )S
0 -1088 M
0 -1105 M
0 -13 R
(If you wish to use some other shading model you have two options. One approach is to create your own routine to)S
0 -1124 M
0 -13 R
(initialize the shading lookup tables. If you take this approach then you may define tables of any size \(there is no need)S
0 -1143 M
0 -13 R
(to use VolPack's encoded normal vectors\). For example, you could use a color transfer function which assigns a)S
0 -1162 M
0 -13 R
(unique color to each possible value of the scalar field in your volume. The second option is to define a callback)S
0 -1181 M
0 -13 R
(routine which will be called to shade each voxel during rendering. You do so by calling )S
FF 17 SF
(vpSetCallback\(\))S
0 -1200 M
RF 17 SF
0 -13 R
(instead of )S
FF 17 SF
(vpSetLookupShader\(\))S
RF 17 SF
(. For example, to declare a grayscale shading callback function use the)S
showpage restore
%%Page: 12 12
save
NP
RF 17 SF
0 0 M
0 -13 R
(following call: )S
0 -19 M
0 -36 M
FF 14 SF
0 -10 R
(    void myshader\(\);)S
0 -51 M
0 -10 R
(    vpSetCallback\(vpc, VP_GRAY_SHADE_FUNC, myshader\);)S
0 -66 M
0 -83 M
RF 17 SF
0 -13 R
(The function )S
FF 17 SF
(myshader\(\))S
RF 17 SF
( can do whatever you like to compute a color. See the man page for )S
0 -102 M
FF 17 SF
0 -13 R
(vpSetCallback\(\))S
RF 17 SF
( for more details. Using callback functions can lead to significant performance degradation)S
0 -121 M
0 -13 R
(during rendering. )S
0 -140 M
0 -157 M
0 -13 R
(There is one more shading option which is independent of the shading model you choose: depth cueing. Depth cueing)S
0 -176 M
0 -13 R
(allows you to introduce black "fog" which makes more distant voxels appear darker then voxels which are close to)S
0 -195 M
0 -13 R
(the viewer, thereby making it easier to distinguish foreground objects from background objects. To enable depth)S
0 -214 M
0 -13 R
(cueing call )S
FF 17 SF
(vpEnable\(\))S
RF 17 SF
(: )S
0 -233 M
0 -250 M
FF 14 SF
0 -10 R
(    vpEnable\(vpc, VP_DEPTH_CUE, 1\);)S
0 -265 M
0 -282 M
RF 17 SF
0 -13 R
(You can use )S
FF 17 SF
(vpSetDepthCueing\(\))S
RF 17 SF
( to change the depth cueing parameters: )S
0 -301 M
0 -318 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -333 M
0 -10 R
(    vpSetDepthCueing\(vpContext *vpc, double front_factor,)S
0 -348 M
0 -10 R
(                     double density\);)S
0 -363 M
0 -380 M
FF 17 SF
0 -13 R
(Front_factor)S
RF 17 SF
( is the transparency of the fog at the front plane of the viewing volume. It must be a positive)S
0 -399 M
0 -13 R
(number and it is usually less than 1.0 \(although larger numbers can be used to brighten the foreground\). )S
FF 17 SF
(Density)S
0 -418 M
RF 17 SF
0 -13 R
(controls the "density" of the fog, or how rapidly objects recede into darkness. The equation for the transparency of)S
0 -437 M
0 -13 R
(the fog is: )S
0 -456 M
20 -473 M
0 -13 R
(T = front_factor * exp\(-density * depth\) )S
20 -492 M
0 -509 M
0 -13 R
(where "depth" is 0 at the front plane of the viewing volume and 1 at the back plane. Each voxel color component is)S
0 -528 M
0 -13 R
(multiplied by the fog transparency during rendering. )S
0 -547 M
0 -564 M
0 -13 R
(VolPack also supports a fast one-pass shadow algorithm implemented with lookup tables \(in a similar fashion to the)S
0 -583 M
0 -13 R
(procedure described above\). See the man page for )S
FF 17 SF
(vpSetShadowLookupShader)S
RF 17 SF
(. )S
0 -602 M
0 -619 M
BF 17 SF
0 -14 R
(Images )S
0 -639 M
0 -656 M
RF 17 SF
0 -13 R
(The last step before rendering is to declare the array that VolPack should store the image into. Use )S
FF 17 SF
(vpSetImage)S
RF 17 SF
(: )S
0 -675 M
0 -692 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -707 M
0 -10 R
(    vpSetImage\(vpContext *vpc, unsigned char *image, int width,)S
0 -722 M
0 -10 R
(               int height, int bytes_per_scan, int pixel_type\);)S
0 -737 M
0 -754 M
FF 17 SF
0 -13 R
(Image)S
RF 17 SF
( is a pointer to the array for the image. The next two arguments are the size of the image. These arguments)S
0 -773 M
0 -13 R
(also implicitly determine the viewport transformation: the clip coordinates are scaled to make the left, right, top and)S
0 -792 M
0 -13 R
(bottom planes of the viewing volume align with the sides of the image. The next argument is the number of bytes in)S
0 -811 M
0 -13 R
(one scanline of the image. This argument can be used to add padding to the end of each scanline in case the image)S
0 -830 M
0 -13 R
(display routines on your system impose alignment restrictions on the beginning of each scanline. Finally, the last)S
0 -849 M
0 -13 R
(argument is a code that specifies the format of the pixels in the image. The following formats are allowed: )S
0 -868 M
0 -885 M
FF 17 SF
0 -13 R
(VP_ALPHA)S
RF 17 SF
( )S
48 -904 M
0 -13 R
(opacity \(1 byte/pixel\) )S
0 -923 M
FF 17 SF
0 -13 R
(VP_LUMINANCE)S
RF 17 SF
( )S
48 -942 M
0 -13 R
(grayscale color \(1 byte/pixel\) )S
0 -961 M
FF 17 SF
0 -13 R
(VP_LUMINANCEA)S
RF 17 SF
( )S
48 -980 M
0 -13 R
(grayscale color plus opacity \(2 bytes/pixel\) )S
0 -999 M
FF 17 SF
0 -13 R
(VP_RGB)S
RF 17 SF
( )S
48 -1018 M
0 -13 R
(RGB color \(3 bytes/pixel\) )S
0 -1037 M
FF 17 SF
0 -13 R
(VP_RGBA)S
RF 17 SF
( )S
48 -1056 M
0 -13 R
(RGB color plus opacity \(4 bytes/pixel\) )S
0 -1075 M
FF 17 SF
0 -13 R
(VP_BGR)S
RF 17 SF
( )S
48 -1094 M
0 -13 R
(RGB color, byte-swapped \(3 bytes/pixel\) )S
0 -1113 M
FF 17 SF
0 -13 R
(VP_ABGR)S
RF 17 SF
( )S
48 -1132 M
0 -13 R
(RGB color plus opacity, bytes-swapped \(4 bytes/pixel\) )S
48 -1151 M
0 -1168 M
0 -13 R
(Use the luminance formats only with grayscale shaders, and the RGB formats only with color shaders. The image)S
0 -1187 M
0 -13 R
(should have dimensions: )S
0 -1206 M
showpage restore
%%Page: 13 13
save
NP
RF 17 SF
0 0 M
FF 14 SF
0 -10 R
(    unsigned char image[bytes_per_scan][height][bytes_per_pixel];)S
0 -15 M
0 -32 M
RF 17 SF
0 -13 R
(where )S
FF 17 SF
(bytes_per_pixel)S
RF 17 SF
( is the size of the pixel as determined by the pixel format. )S
0 -51 M
0 -68 M
BF 17 SF
0 -14 R
(Rendering )S
0 -88 M
0 -105 M
RF 17 SF
0 -13 R
(VolPack provides two rendering routines. The first routine is used to render pre-classified volumes which are)S
0 -124 M
0 -13 R
(created with the routines in the )S
(Classified Volumes)S
( subsection: )S
0 -143 M
0 -160 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -175 M
0 -10 R
(    vpRenderClassifiedVolume\(vpContext *vpc\);)S
0 -190 M
0 -207 M
RF 17 SF
0 -13 R
(This routine uses the current viewing and shading parameters to render the classified volume stored in the rendering)S
0 -226 M
0 -13 R
(context. The result is placed in the image buffer declared with )S
FF 17 SF
(vpSetImage\(\))S
RF 17 SF
(. )S
0 -245 M
0 -262 M
0 -13 R
(The second routine is used to render unclassified volumes which are created with the routines in the )S
(Volumes)S
0 -281 M
0 -13 R
(subsection: )S
0 -300 M
0 -317 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -332 M
0 -10 R
(    vpRenderRawVolume\(vpContext *vpc\);)S
0 -347 M
0 -364 M
RF 17 SF
0 -13 R
(This routine is identical to )S
FF 17 SF
(vpRenderClassifiedVolume\(\))S
RF 17 SF
( except that the source of the volume data is the)S
0 -383 M
0 -13 R
(raw volume data stored in the rendering context, and the volume data is classified on-the-fly during rendering. If a)S
0 -402 M
0 -13 R
(min-max octree data structure is present in the rendering context then it is used to accelerate rendering. However,)S
0 -421 M
0 -13 R
(even with the octree this routine is slower than )S
FF 17 SF
(vpRenderClassifiedVolume\(\))S
RF 17 SF
( because of the additional)S
0 -440 M
0 -13 R
(work which must be performed. )S
0 -459 M
0 -476 M
0 -13 R
(There is one important state variable which can be used to improve rendering performance: the maximum ray)S
0 -495 M
0 -13 R
(opacity threshold. During compositing, if the opacity of an image pixel reaches this threshold then no more voxel)S
0 -514 M
0 -13 R
(data is composited into the pixel. The threshold should be a number slightly less than one \(0.95 is a good value\), so)S
0 -533 M
0 -13 R
(that there is very little image degradation but voxels which do not make a significant contribution to the image can)S
0 -552 M
0 -13 R
(be skipped. You set the threshold with )S
FF 17 SF
(vpSetd\(\))S
RF 17 SF
( and the )S
FF 17 SF
(VP_MAX_RAY_OPACITY)S
RF 17 SF
( option. For example: )S
0 -571 M
0 -588 M
FF 14 SF
0 -10 R
(    vpSetd\(vpc, VP_MAX_RAY_OPACITY, 0.95\);)S
0 -603 M
0 -620 M
BF 17 SF
0 -14 R
(State Variables )S
0 -640 M
0 -657 M
RF 17 SF
0 -13 R
(The previous subsections have described many routines which set state variables in a rendering context. This)S
0 -676 M
0 -13 R
(subsection briefly mentions the routines available to retrieve the values of these variables. )S
0 -695 M
0 -712 M
0 -13 R
(The function )S
FF 17 SF
(vpGeti\(\))S
RF 17 SF
( is used to retrieve integer state variables: )S
0 -731 M
0 -748 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -763 M
0 -10 R
(    vpGeti\(vpContext *vpc, int option, int *iptr\);)S
0 -778 M
0 -795 M
FF 17 SF
0 -13 R
(Option)S
RF 17 SF
( is a constant indicating the particular value you wish to get. The man page for )S
FF 17 SF
(vpGeti)S
RF 17 SF
( lists all of the)S
0 -814 M
0 -13 R
(options. The value is stored in the integer pointed to by )S
FF 17 SF
(iptr)S
RF 17 SF
(. As always, the return value of the routine is a result)S
0 -833 M
0 -13 R
(code \(not the state variable value\). )S
0 -852 M
0 -869 M
0 -13 R
(To retrieve floating-point state variables used )S
FF 17 SF
(vpGetd\(\))S
RF 17 SF
(: )S
0 -888 M
0 -905 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -920 M
0 -10 R
(    vpGetd\(vpContext *vpc, int option, double *dptr\);)S
0 -935 M
0 -952 M
RF 17 SF
0 -13 R
(This routine stores its result in the double pointed to by )S
FF 17 SF
(dptr)S
RF 17 SF
(. To retrieve pointers \(e.g. the current raw volume data)S
0 -971 M
0 -13 R
(pointer\) use )S
FF 17 SF
(vpGetp)S
RF 17 SF
(: )S
0 -990 M
0 -1007 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -1022 M
0 -10 R
(    vpGetp\(vpContext *vpc, int option, void **pptr\);)S
0 -1037 M
0 -1054 M
FF 17 SF
0 -13 R
(Pptr)S
RF 17 SF
( is a pointer to a pointer, so the value of the state variable is stored in )S
FF 17 SF
(*ptr)S
RF 17 SF
(. Transformation matrices can be)S
0 -1073 M
0 -13 R
(retrieved with )S
FF 17 SF
(vpGetMatrix\(\))S
RF 17 SF
(: )S
0 -1092 M
0 -1109 M
FF 14 SF
0 -10 R
(    vpResult)S
0 -1124 M
0 -10 R
(    vpGetMatrix\(vpContext *vpc, int option, vpMatrix4 m\);)S
0 -1139 M
0 -1156 M
RF 17 SF
0 -13 R
(The matrix values are stored in )S
FF 17 SF
(m)S
RF 17 SF
(. )S
0 -1175 M
0 -1192 M
0 -13 R
(Lighting and material parameters can be retrieved with )S
FF 17 SF
(vpGetLight\(\))S
RF 17 SF
( and )S
FF 17 SF
(vpGetMaterial\(\))S
RF 17 SF
( which have)S
0 -1211 M
0 -13 R
(arguments which are similar to the corresponding functions to set these parameters. )S
showpage restore
%%Page: 14 14
save
NP
RF 17 SF
0 0 M
0 -17 M
BF 17 SF
0 -14 R
(Utility Functions )S
0 -37 M
0 -54 M
RF 17 SF
0 -13 R
(VolPack provides a small collection of convenient utility functions. First, there are routines to store volume data)S
0 -73 M
0 -13 R
(structures in files and load them back into a rendering context. They allow you to perform all of the)S
0 -92 M
0 -13 R
(time-consuming preprocessing steps once and save the results in a file. See the man pages for the following routines:)S
0 -111 M
48 -128 M
0 -10 R
 3.454545 B
FF 17 SF
0 -3 R
(vpStoreRawVolume\(\))S
RF 17 SF
( )S
48 -147 M
0 -10 R
 3.454545 B
FF 17 SF
0 -3 R
(vpLoadRawVolume\(\))S
RF 17 SF
( )S
48 -166 M
0 -10 R
 3.454545 B
FF 17 SF
0 -3 R
(vpStoreClassifiedVolume\(\))S
RF 17 SF
( )S
48 -185 M
0 -10 R
 3.454545 B
FF 17 SF
0 -3 R
(vpLoadClassifiedVolume\(\))S
RF 17 SF
( )S
48 -204 M
0 -10 R
 3.454545 B
FF 17 SF
0 -3 R
(vpStoreMinMaxOctree\(\))S
RF 17 SF
( )S
48 -223 M
0 -10 R
 3.454545 B
FF 17 SF
0 -3 R
(vpLoadMinMaxOctree\(\))S
RF 17 SF
( )S
48 -242 M
0 -259 M
0 -13 R
(The routine )S
FF 17 SF
(vpExtract\(\))S
RF 17 SF
( allows you to extract a rectangular solid region from either the raw volume data or the)S
0 -278 M
0 -13 R
(classified volume data. You can extract individual fields of the volume \(e.g. just the scalar data\), or computed values)S
0 -297 M
0 -13 R
(\(e.g. opacity computed with the current classification function\). )S
0 -316 M
0 -333 M
0 -13 R
(The routine )S
FF 17 SF
(vpTranspose\(\))S
RF 17 SF
( allows you to transpose the raw volume data. This can be useful to improve)S
0 -352 M
0 -13 R
(rendering performance for very large volumes. You can use )S
FF 17 SF
(vpGeti)S
RF 17 SF
( with the )S
FF 17 SF
(VP_VIEW_AXIS)S
RF 17 SF
( option to)S
0 -371 M
0 -13 R
(determine how the volume should be transposed for optimum performance given the current viewing parameters. )S
0 -390 M
0 -407 M
0 -13 R
(The routine )S
FF 17 SF
(vpResample\(\))S
RF 17 SF
( allows you to scale a volume to a different resolution using a variety of resampling)S
0 -426 M
0 -13 R
(filters. It is useful for scaling very large volumes down to a smaller size for fast previewing, or to filter)S
0 -445 M
0 -13 R
(low-resolution data sets to a higher resolution with a high-quality filter before rendering. )S
0 -464 M
0 -481 M
BF 17 SF
0 -14 R
(Result Codes and Error Handling )S
0 -501 M
0 -518 M
RF 17 SF
0 -13 R
(Almost all of the routines in VolPack return a result of type )S
FF 17 SF
(vpResult)S
RF 17 SF
( which is an integer. Routines return the)S
0 -537 M
0 -13 R
(value )S
FF 17 SF
(VP_OK)S
RF 17 SF
( to indicate success. Any other value indicates an error. See the man page for each function for the)S
0 -556 M
0 -13 R
(possible error codes and their specific meanings. )S
0 -575 M
0 -592 M
0 -13 R
(When an error occurs VolPack also records the error code in the rendering context. You can retrieve the error code)S
0 -611 M
0 -13 R
(later by calling )S
FF 17 SF
(vpGetError\(\))S
RF 17 SF
(. If another error occurs before you call )S
FF 17 SF
(vpGetError\(\))S
RF 17 SF
( then only the first one)S
0 -630 M
0 -13 R
(is returned. The recorded value is then reset. )S
0 -649 M
0 -666 M
0 -13 R
(The routine )S
FF 17 SF
(vpGetErrorString\(\))S
RF 17 SF
( can be used to convert an error code into a printable string. )S
0 -685 M
0 -702 M
BF 18 SF
0 -15 R
(Section 3: Tips and Pointers )S
0 -723 M
0 -740 M
BF 17 SF
0 -14 R
(Maximizing Rendering Speed )S
0 -760 M
0 -777 M
RF 17 SF
0 -13 R
(There are several techniques to keep in mind to get the maximum possible performance out of VolPack. First of all,)S
0 -796 M
0 -13 R
(use the appropriate rendering algorithm for the task at hand. If you want to render a volume from several viewpoints)S
0 -815 M
0 -13 R
(without changing the classification function then it is well worth the time to preprocess the volume into the)S
0 -834 M
0 -13 R
(run-length encoded format before rendering. Use the min-max octree data structure if the classification function)S
0 -853 M
0 -13 R
(does change for every rendering but the volume data remains fixed. )S
0 -872 M
0 -889 M
0 -13 R
(Second, choose the various thresholds carefully. Changing the minimum opacity threshold for classification and the)S
0 -908 M
0 -13 R
(maximum ray opacity for rendering can have a big impact on rendering speed. Changing the parameter range)S
0 -927 M
0 -13 R
(thresholds for the min-max octree can also improve performance. )S
0 -946 M
0 -963 M
0 -13 R
(Third, minimize the need for reallocating internal data structures by predeclaring their sizes. Internal buffers are)S
0 -982 M
0 -13 R
(used to store an intermediate image during rendering and a depth cueing lookup table. The sizes of these tables can)S
0 -1001 M
0 -13 R
(change as the viewing parameters change, so the tables may have to be reallocated over the course of a multi-frame)S
0 -1020 M
0 -13 R
(rendering loop. You can give VolPack "hints" for the sizes of these data structures using )S
FF 17 SF
(vpSeti\(\))S
RF 17 SF
( with the )S
0 -1039 M
FF 17 SF
0 -13 R
(VP_INT_WIDTH_HINT)S
RF 17 SF
(, )S
FF 17 SF
(VP_INT_HEIGHT_HINT)S
RF 17 SF
( and )S
FF 17 SF
(VP_DEPTH_CUE_SIZE_HINT)S
RF 17 SF
( options. )S
0 -1058 M
0 -1075 M
0 -13 R
(Finally, if you are using )S
FF 17 SF
(vpRenderRawVolume\(\))S
RF 17 SF
( with a large volume then you may need to transpose the)S
0 -1094 M
0 -13 R
(volume as the viewing direction changes from one principal axis to another. )S
0 -1113 M
0 -1130 M
BF 17 SF
0 -14 R
(Maximizing Image Quality )S
0 -1150 M
0 -1167 M
RF 17 SF
0 -13 R
(There are two important techniques which will help you to produce images free from distracting aliasing artifacts.)S
0 -1186 M
0 -13 R
(The first is to choose classification functions that are fairly smooth. Functions with discontinuities or very abrupt)S
0 -1205 M
0 -13 R
(transitions introduce very sharp transitions in the classified volume, and these transitions may be too sharp to be)S
showpage restore
%%Page: 15 15
save
NP
RF 17 SF
0 0 M
0 -13 R
(properly sampled. The result can be jagged boundaries and spurious patterns in the rendered image. These artifacts)S
0 -19 M
0 -13 R
(may be difficult to distinguish from the information in the data set. To diagnose this problem, try extracting slices)S
0 -38 M
0 -13 R
(of classified volume data with )S
FF 17 SF
(vpExtract\(\))S
RF 17 SF
( and check if the opacity images contain a lot of aliasing. Smooth)S
0 -57 M
0 -13 R
(transitions will produce the best images. )S
0 -76 M
0 -93 M
0 -13 R
(The second technique is to prefilter the volume data with a high-quality filter before scaling or zooming, rather than)S
0 -112 M
0 -13 R
(using the viewing transformation to do the scaling. There are two reasons that prefiltering may help. The rendering)S
0 -131 M
0 -13 R
(routines use a simple bilinear reconstruction filter, but if you prefilter you can use a higher-quality filter which does)S
0 -150 M
0 -13 R
(a better job of reconstruction. Furthermore, the resolution of the rendered image is limited by the number of samples)S
0 -169 M
0 -13 R
(in the volume, so very large magnification factors produce visible aliasing artifacts. Upscaling the volume with a)S
0 -188 M
0 -13 R
(high-quality filter before rendering can solve this problem. Several utility routines, described in the )S
0 -207 M
FF 17 SF
0 -13 R
(vpResample\(\))S
RF 17 SF
( man page, are provided for prefiltering a volume. )S
0 -226 M
0 -243 M
BF 17 SF
0 -14 R
(Software Support )S
0 -263 M
0 -280 M
RF 17 SF
0 -13 R
(If you have problems, bug reports or bug fixes, please send mail to: )S
0 -299 M
20 -316 M
IF 17 SF
0 -13 R
(volpack@graphics.stanford.edu )S
20 -335 M
0 -352 M
RF 17 SF
0 -13 R
(The author makes no commitment to fix bugs or provide support. However, future releases with fixes and)S
0 -371 M
0 -13 R
(enhancements are planned. )S
0 -390 M
0 -407 M
0 -13 R
(If you wish to be informed of future updates to the software then you should subscribe to the volpack-announce)S
0 -426 M
0 -13 R
(mailing list. To do so, send an email message to )S
0 -445 M
20 -462 M
IF 17 SF
0 -13 R
(majordomo@lists.stanford.edu )S
20 -481 M
0 -498 M
RF 17 SF
0 -13 R
(with the following message body: )S
0 -517 M
20 -534 M
0 -13 R
(subscribe volpack-announce )S
20 -553 M
0 -570 M
0 -13 R
(To be removed from the list, send the message: )S
0 -589 M
20 -606 M
0 -13 R
(unsubscribe volpack-announce )S
20 -625 M
0 -642 M
0 -13 R
(Mail will be sent to the list only to announce bug fixes and new releases. )S
0 -661 M
0 -678 M
0 -13 R
(If you like the library then drop us a note describing what you use it for! )S
0 -697 M
0 -714 M
BF 17 SF
0 -14 R
(Obtaining the Software )S
0 -734 M
0 -751 M
RF 17 SF
0 -13 R
(VolPack is available from the Stanford Computer Graphics Laboratory's Web page )S
0 -770 M
0 -13 R
(\(http://www-graphics.stanford.edu/software/volpack/#Distribution\) )S
(or via anonymous ftp)S
0 -789 M
0 -13 R
(\(ftp://www-graphics.stanford.edu/pub/volpack/\). )S
0 -808 M
805 HR
0 -827 M
0 -13 R
(Last update: 16 December 1994 )S
0 -846 M
IF 17 SF
0 -13 R
(volpack@graphics.stanford.edu )S
showpage restore
%%Trailer
restore
%%Pages: 15
