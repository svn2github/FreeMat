<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<HTML>
<HEAD>
<TITLE>COLON Index Generation Operator
</TITLE>
</HEAD>
<BODY>
<H2>COLON Index Generation Operator
</H2>
<P>
Section: <A HREF=sec_operators.html> Mathematical Operators </A>
<H3>Usage</H3>
There are two distinct syntaxes for the colon <code>:</code> operator - the two argument form
<PRE>
  y = a : c
</PRE>
<P>
and the three argument form
<PRE>
  y = a : b : c
</PRE>
<P>
The two argument form is exactly equivalent to <code>a:1:c</code>.  The output <code>y</code> is the vector
<P>
<DIV ALIGN="CENTER">
<IMG SRC="colon_eqn1.png">
</DIV>
<P>
where <code>a+nb &lt;= c</code>.  There is a third form of the colon operator, the
no-argument form used in indexing (see <code>indexing</code> for more details).
<H3>Function Internals</H3>
The colon operator turns out to be trickier to implement than one might
believe at first, primarily because the floating point versions should
do the right thing, which is not the obvious behavior.  For example,
suppose the user issues a three point colon command
<PRE>
   y = a : b : c
</PRE>
<P>
The first question that one might need to answer is: how many points
in this vector?  If you answered
<P>
<DIV ALIGN="CENTER">
<IMG SRC="colon_eqn2.png">
</DIV>
<P>
then you would be doing the straighforward, but not correct thing.
because a, b, and c are all floating point values, there are errors
associated with each of the quantities that can lead to n not being
an integer.  A better way (and the way FreeMat currently does the
calculation) is to compute the bounding values (for b positive)
<P>
<DIV ALIGN="CENTER">
<IMG SRC="colon_eqn3.png">
</DIV>
<P>
where
<P>
<DIV ALIGN="CENTER">
<IMG SRC="colon_eqn4.png">
</DIV>
<P>
means we replace x by the floating point number that is closest to it
in the direction of y.  Once we have determined the number of points
we have to compute the intermediate values
<P>
<DIV ALIGN="CENTER">
<IMG SRC="colon_eqn5.png">
</DIV>
<P>
but one can readily verify for themselves that this may \emph{not} be
the same as the vector
<P>
<DIV ALIGN="CENTER">
<IMG SRC="colon_eqn6.png">
</DIV>
<P>
even for the case where
<P>
<DIV ALIGN="CENTER">
<IMG SRC="colon_eqn7.png">
</DIV>
<P>
for some n.  The reason is that the roundoff in the calculations may
be different depending on the nature of the sum.  FreeMat uses the
following strategy to compute the double-colon vector:
\begin{enumerate}
\item The value <code>n</code> is computed by taking the floor of the larger
 value in the interval defined above.
\item If <code>n</code> falls inside the interval defined above, then it is
assumed that the user intended <code>c = a + n*b</code>, and the symmetric
algorithm is used.  Otherwise, the nonsymmetric algorithm is used.
\item The symmetric algorithm computes the vector via
<P>
<DIV ALIGN="CENTER">
<IMG SRC="colon_eqn8.png">
</DIV>
<P>
working symmetrically from both ends of the vector
(hence the nomenclature), while the nonsymmetric algorithm computes
<P>
<DIV ALIGN="CENTER">
<IMG SRC="colon_eqn9.png">
</DIV>
<P>
In practice, the entries are computed by repeated accumulation instead
of multiplying the step size by an integer.
\item The real interval calculation is modified so that we get the
exact same result with <code>a:b:c</code> and <code>c:-b:a</code> (which basically means
that instead of moving towards infinity, we move towards the signed
infinity where the sign is inherited from <code>b</code>).
\end{enumerate}
If you think this is all very obscure, it is.  But without it, you will
be confronted by mysterious vectors where the last entry is dropped,
or where the values show progressively larger amounts of accumulated
roundoff error.
<H3>Examples</H3>
Some simple examples of index generation.
<PRE>
--&gt; y = 1:4

y = 
 1 2 3 4 
</PRE>
Now by half-steps:
<PRE>
--&gt; y = 1:.5:4

y = 
    1.0000    1.5000    2.0000    2.5000    3.0000    3.5000    4.0000 
</PRE>
Now going backwards (negative steps)
<PRE>
--&gt; y = 4:-.5:1

y = 
    4.0000    3.5000    3.0000    2.5000    2.0000    1.5000    1.0000 
</PRE>
If the endpoints are the same, one point is generated, regardless of the step size (middle argument)
<PRE>
--&gt; y = 4:1:4

y = 
 4 
</PRE>
If the endpoints define an empty interval, the output is an empty matrix:
<PRE>
--&gt; y = 5:4

y = 
  Empty array 1x0
</PRE>
</BODY>
</HTML>
