<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<HTML>
<HEAD>
<TITLE>vtkPCAAnalysisFilter
</TITLE>
</HEAD>
<BODY>
<H2>vtkPCAAnalysisFilter
</H2>
<P>
Section: <A HREF=sec_vtkhybrid.html> Visualization Toolkit Hybrid Classes </A>
<H3>Usage</H3>
<P>
 vtkPCAAnalysisFilter is a filter that takes as input a set of aligned
 pointsets (any object derived from vtkPointSet) and performs
 a principal component analysis of the coordinates. 
 This can be used to visualise the major or minor modes of variation
 seen in a set of similar biological objects with corresponding
 landmarks.
 vtkPCAAnalysisFilter is designed to work with the output from
 the vtkProcrustesAnalysisFilter
 
 Call SetNumberOfInputs(n) before calling SetInput(0) ... SetInput(n-1).
 Retrieve the outputs using GetOutput(0) ... GetOutput(n-1).
<P>
 vtkPCAAnalysisFilter is an implementation of (for example):
<P>
 T. Cootes et al. : Active Shape Models - their training and application.
 Computer Vision and Image Understanding, 61(1):38-59, 1995.
<P>
 The material can also be found in Tim Cootes' ever-changing online report
 published at his website:
 http://www.isbe.man.ac.uk/~bim/
<P>
<P>
To create an instance of class vtkPCAAnalysisFilter, simply
invoke its constructor as follows
<PRE>
  obj = vtkPCAAnalysisFilter
</PRE>
<P>
<H3>Methods</H3>
The class vtkPCAAnalysisFilter has several methods that can be used.
  They are listed below.
Note that the documentation is translated automatically from the VTK sources,
and may not be completely intelligible.  When in doubt, consult the VTK website.
In the methods listed below, <code>obj</code> is an instance of the vtkPCAAnalysisFilter class.
<UL>
<LI>  <code>string = obj.GetClassName ()</code>
 </LI>
<LI>  <code>int = obj.IsA (string name)</code>
 </LI>
<LI>  <code>vtkPCAAnalysisFilter = obj.NewInstance ()</code>
 </LI>
<LI>  <code>vtkPCAAnalysisFilter = obj.SafeDownCast (vtkObject o)</code>
 </LI>
<LI>  <code>vtkFloatArray = obj.GetEvals ()</code> -  Get the vector of eigenvalues sorted in descending order
 </LI>
<LI>  <code>obj.SetNumberOfInputs (int n)</code> -  Specify how many pointsets are going to be given as input.
 </LI>
<LI>  <code>obj.SetInput (int idx, vtkPointSet p)</code> -  Specify the input pointset with index idx.
 Call SetNumberOfInputs before calling this function.
 </LI>
<LI>  <code>obj.SetInput (int idx, vtkDataObject input)</code> -  Specify the input pointset with index idx.
 Call SetNumberOfInputs before calling this function.
 </LI>
<LI>  <code>vtkPointSet = obj.GetInput (int idx)</code> -  Retrieve the input with index idx (usually only used for pipeline
 tracing).
 </LI>
<LI>  <code>obj.GetParameterisedShape (vtkFloatArray b, vtkPointSet shape)</code> -  Fills the shape with:

 mean + b[0] * sqrt(eigenvalue[0]) * eigenvector[0]
      + b[1] * sqrt(eigenvalue[1]) * eigenvector[1]
 ...
      + b[sizeb-1] * sqrt(eigenvalue[bsize-1]) * eigenvector[bsize-1]

 here b are the parameters expressed in standard deviations
 bsize is the number of parameters in the b vector
 This function assumes that shape is allready allocated
 with the right size, it just moves the points.
 </LI>
<LI>  <code>obj.GetShapeParameters (vtkPointSet shape, vtkFloatArray b, int bsize)</code> -  Return the bsize parameters b that best model the given shape
 (in standard deviations). 
 That is that the given shape will be approximated by:

 shape ~ mean + b[0] * sqrt(eigenvalue[0]) * eigenvector[0]
              + b[1] * sqrt(eigenvalue[1]) * eigenvector[1]
         ...
              + b[bsize-1] * sqrt(eigenvalue[bsize-1]) * eigenvector[bsize-1]
 </LI>
<LI>  <code>int = obj.GetModesRequiredFor (double proportion)</code> -  Retrieve how many modes are necessary to model the given proportion of the variation.
 proportion should be between 0 and 1
 </LI>
</UL>
</BODY>
</HTML>
