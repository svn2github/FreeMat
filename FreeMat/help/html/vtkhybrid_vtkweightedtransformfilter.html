<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<HTML>
<HEAD>
<TITLE>vtkWeightedTransformFilter
</TITLE>
</HEAD>
<BODY>
<H2>vtkWeightedTransformFilter
</H2>
<P>
Section: <A HREF=sec_vtkhybrid.html> Visualization Toolkit Hybrid Classes </A>
<H3>Usage</H3>
<P>
To create an instance of class vtkWeightedTransformFilter, simply
invoke its constructor as follows
<PRE>
  obj = vtkWeightedTransformFilter
</PRE>
<P>
<H3>Methods</H3>
The class vtkWeightedTransformFilter has several methods that can be used.
  They are listed below.
Note that the documentation is translated automatically from the VTK sources,
and may not be completely intelligible.  When in doubt, consult the VTK website.
In the methods listed below, <code>obj</code> is an instance of the vtkWeightedTransformFilter class.
<UL>
<LI>  <code>string = obj.GetClassName ()</code>
 </LI>
<LI>  <code>int = obj.IsA (string name)</code>
 </LI>
<LI>  <code>vtkWeightedTransformFilter = obj.NewInstance ()</code>
 </LI>
<LI>  <code>vtkWeightedTransformFilter = obj.SafeDownCast (vtkObject o)</code>
 </LI>
<LI>  <code>long = obj.GetMTime ()</code> -  Return the MTime also considering the filter's transforms.
 </LI>
<LI>  <code>obj.SetWeightArray (string )</code> -  WeightArray is the string name of the DataArray in the input's
 FieldData that holds the weighting coefficients for each point.
 The filter will first look for the array in the input's PointData
 FieldData.  If the array isn't there, the filter looks in the
 input's FieldData.  The WeightArray can have tuples of any length,
 but must have a tuple for every point in the input data set.
 This array transforms points, normals, and vectors.
 </LI>
<LI>  <code>string = obj.GetWeightArray ()</code> -  WeightArray is the string name of the DataArray in the input's
 FieldData that holds the weighting coefficients for each point.
 The filter will first look for the array in the input's PointData
 FieldData.  If the array isn't there, the filter looks in the
 input's FieldData.  The WeightArray can have tuples of any length,
 but must have a tuple for every point in the input data set.
 This array transforms points, normals, and vectors.
 </LI>
<LI>  <code>obj.SetTransformIndexArray (string )</code> -  TransformIndexArray is the string name of the DataArray in the input's
 FieldData that holds the indices for the transforms for each point.
 These indices are used to select which transforms each weight of
 the DataArray refers.  If the TransformIndexArray is not specified,
 the weights of each point are assumed to map directly to a transform.
 This DataArray must be of type UnsignedShort, which effectively
 limits the number of transforms to 65536 if a transform index 
 array is used.
 
 The filter will first look for the array in the input's PointData
 FieldData.  If the array isn't there, the filter looks in the
 input's FieldData.  The TransformIndexArray can have tuples of any 
 length, but must have a tuple for every point in the input data set.
 This array transforms points, normals, and vectors.
 </LI>
<LI>  <code>string = obj.GetTransformIndexArray ()</code> -  TransformIndexArray is the string name of the DataArray in the input's
 FieldData that holds the indices for the transforms for each point.
 These indices are used to select which transforms each weight of
 the DataArray refers.  If the TransformIndexArray is not specified,
 the weights of each point are assumed to map directly to a transform.
 This DataArray must be of type UnsignedShort, which effectively
 limits the number of transforms to 65536 if a transform index 
 array is used.
 
 The filter will first look for the array in the input's PointData
 FieldData.  If the array isn't there, the filter looks in the
 input's FieldData.  The TransformIndexArray can have tuples of any 
 length, but must have a tuple for every point in the input data set.
 This array transforms points, normals, and vectors.
 </LI>
<LI>  <code>obj.SetCellDataWeightArray (string )</code> -  The CellDataWeightArray is analogous to the WeightArray, except
 for CellData.  The array is searched for first in the CellData 
 FieldData, then in the input's FieldData.  The data array must have
 a tuple for each cell.  This array is used to transform only normals
 and vectors.
 </LI>
<LI>  <code>string = obj.GetCellDataWeightArray ()</code> -  The CellDataWeightArray is analogous to the WeightArray, except
 for CellData.  The array is searched for first in the CellData 
 FieldData, then in the input's FieldData.  The data array must have
 a tuple for each cell.  This array is used to transform only normals
 and vectors.
 </LI>
<LI>  <code>obj.SetCellDataTransformIndexArray (string )</code>
 </LI>
<LI>  <code>string = obj.GetCellDataTransformIndexArray ()</code>
 </LI>
<LI>  <code>obj.SetTransform (vtkAbstractTransform transform, int num)</code> -  Set or Get one of the filter's transforms. The transform number must
 be less than the number of transforms allocated for the object.  Setting
 a transform slot to NULL is equivalent to assigning an overriding weight
 of zero to that filter slot.
 </LI>
<LI>  <code>vtkAbstractTransform = obj.GetTransform (int num)</code> -  Set or Get one of the filter's transforms. The transform number must
 be less than the number of transforms allocated for the object.  Setting
 a transform slot to NULL is equivalent to assigning an overriding weight
 of zero to that filter slot.
 </LI>
<LI>  <code>obj.SetNumberOfTransforms (int num)</code> -  Set the number of transforms for the filter.  References to non-existent
 filter numbers in the data array is equivalent to a weight of zero
 (i.e., no contribution of that filter or weight).  The maximum number of 
 transforms is limited to 65536 if transform index arrays are used.
 </LI>
<LI>  <code>int = obj.GetNumberOfTransforms ()</code> -  Set the number of transforms for the filter.  References to non-existent
 filter numbers in the data array is equivalent to a weight of zero
 (i.e., no contribution of that filter or weight).  The maximum number of 
 transforms is limited to 65536 if transform index arrays are used.
 </LI>
<LI>  <code>obj.AddInputValuesOn ()</code> -  If AddInputValues is true, the output values of this filter will be
 offset from the input values.  The effect is exactly equivalent to
 having an identity transform of weight 1 added into each output point.
 </LI>
<LI>  <code>obj.AddInputValuesOff ()</code> -  If AddInputValues is true, the output values of this filter will be
 offset from the input values.  The effect is exactly equivalent to
 having an identity transform of weight 1 added into each output point.
 </LI>
<LI>  <code>obj.SetAddInputValues (int )</code> -  If AddInputValues is true, the output values of this filter will be
 offset from the input values.  The effect is exactly equivalent to
 having an identity transform of weight 1 added into each output point.
 </LI>
<LI>  <code>int = obj.GetAddInputValues ()</code> -  If AddInputValues is true, the output values of this filter will be
 offset from the input values.  The effect is exactly equivalent to
 having an identity transform of weight 1 added into each output point.
 </LI>
</UL>
</BODY>
</HTML>
