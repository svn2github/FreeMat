<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<HTML>
<HEAD>
<TITLE>vtkTemporalFractal
</TITLE>
</HEAD>
<BODY>
<H2>vtkTemporalFractal
</H2>
<P>
Section: <A HREF=sec_vtkparallel.html> Visualization Toolkit Parallel Classes </A>
<H3>Usage</H3>
 vtkTemporalFractal is a collection of uniform grids.  All have the same
 dimensions. Each block has a different origin and spacing.  It uses
 mandelbrot to create cell data. I scale the fractal array to look like a
 volme fraction.
 I may also add block id and level as extra cell arrays.
 This source produces a vtkHierarchicalBoxDataSet when 
 GenerateRectilinearGrids is off, otherwise produces a vtkMultiBlockDataSet.
<P>
To create an instance of class vtkTemporalFractal, simply
invoke its constructor as follows
<PRE>
  obj = vtkTemporalFractal
</PRE>
<P>
<H3>Methods</H3>
The class vtkTemporalFractal has several methods that can be used.
  They are listed below.
Note that the documentation is translated automatically from the VTK sources,
and may not be completely intelligible.  When in doubt, consult the VTK website.
In the methods listed below, <code>obj</code> is an instance of the vtkTemporalFractal class.
<UL>
<LI>  <code>string = obj.GetClassName ()</code>
 </LI>
<LI>  <code>int = obj.IsA (string name)</code>
 </LI>
<LI>  <code>vtkTemporalFractal = obj.NewInstance ()</code>
 </LI>
<LI>  <code>vtkTemporalFractal = obj.SafeDownCast (vtkObject o)</code>
 </LI>
<LI>  <code>obj.SetFractalValue (float )</code> -  Essentially the iso surface value.
 The fractal array is scaled to map this value to 0.5 for use as a volume
 fraction.
 </LI>
<LI>  <code>float = obj.GetFractalValue ()</code> -  Essentially the iso surface value.
 The fractal array is scaled to map this value to 0.5 for use as a volume
 fraction.
 </LI>
<LI>  <code>obj.SetMaximumLevel (int )</code> -  Any blocks touching a predefined line will be subdivided to this level.
 Other blocks are subdivided so that neighboring blocks only differ
 by one level.
 </LI>
<LI>  <code>int = obj.GetMaximumLevel ()</code> -  Any blocks touching a predefined line will be subdivided to this level.
 Other blocks are subdivided so that neighboring blocks only differ
 by one level.
 </LI>
<LI>  <code>obj.SetDimensions (int )</code> -  XYZ dimensions of cells.
 </LI>
<LI>  <code>int = obj.GetDimensions ()</code> -  XYZ dimensions of cells.
 </LI>
<LI>  <code>obj.SetGhostLevels (int )</code> -  For testing ghost levels.
 </LI>
<LI>  <code>int = obj.GetGhostLevels ()</code> -  For testing ghost levels.
 </LI>
<LI>  <code>obj.GhostLevelsOn ()</code> -  For testing ghost levels.
 </LI>
<LI>  <code>obj.GhostLevelsOff ()</code> -  For testing ghost levels.
 </LI>
<LI>  <code>obj.SetGenerateRectilinearGrids (int )</code> -  Generate either rectilinear grids either uniform grids.
 Default is false.
 </LI>
<LI>  <code>int = obj.GetGenerateRectilinearGrids ()</code> -  Generate either rectilinear grids either uniform grids.
 Default is false.
 </LI>
<LI>  <code>obj.GenerateRectilinearGridsOn ()</code> -  Generate either rectilinear grids either uniform grids.
 Default is false.
 </LI>
<LI>  <code>obj.GenerateRectilinearGridsOff ()</code> -  Generate either rectilinear grids either uniform grids.
 Default is false.
 </LI>
<LI>  <code>obj.SetDiscreteTimeSteps (int )</code> -  Limit this source to discrete integer time steps
 Default is off (continuous)
 </LI>
<LI>  <code>int = obj.GetDiscreteTimeSteps ()</code> -  Limit this source to discrete integer time steps
 Default is off (continuous)
 </LI>
<LI>  <code>obj.DiscreteTimeStepsOn ()</code> -  Limit this source to discrete integer time steps
 Default is off (continuous)
 </LI>
<LI>  <code>obj.DiscreteTimeStepsOff ()</code> -  Limit this source to discrete integer time steps
 Default is off (continuous)
 </LI>
<LI>  <code>obj.SetTwoDimensional (int )</code> -  Make a 2D data set to test.
 </LI>
<LI>  <code>int = obj.GetTwoDimensional ()</code> -  Make a 2D data set to test.
 </LI>
<LI>  <code>obj.TwoDimensionalOn ()</code> -  Make a 2D data set to test.
 </LI>
<LI>  <code>obj.TwoDimensionalOff ()</code> -  Make a 2D data set to test.
 </LI>
<LI>  <code>obj.SetAsymetric (int )</code> -  Test the case when the blocks do not have the same sizes.
 Adds 2 to the x extent of the far x blocks (level 1).
 </LI>
<LI>  <code>int = obj.GetAsymetric ()</code> -  Test the case when the blocks do not have the same sizes.
 Adds 2 to the x extent of the far x blocks (level 1).
 </LI>
<LI>  <code>obj.SetAdaptiveSubdivision (int )</code> -  Make the division adaptive or not, defaults to Adaptive
 </LI>
<LI>  <code>int = obj.GetAdaptiveSubdivision ()</code> -  Make the division adaptive or not, defaults to Adaptive
 </LI>
<LI>  <code>obj.AdaptiveSubdivisionOn ()</code> -  Make the division adaptive or not, defaults to Adaptive
 </LI>
<LI>  <code>obj.AdaptiveSubdivisionOff ()</code> -  Make the division adaptive or not, defaults to Adaptive
 </LI>
</UL>
</BODY>
</HTML>
