\section{vtkWarpTransform}

\subsection{Usage}

 vtkWarpTransform provides a generic interface for nonlinear 
 warp transformations.

To create an instance of class vtkWarpTransform, simply
invoke its constructor as follows
\begin{verbatim}
  obj = vtkWarpTransform
\end{verbatim}
\subsection{Methods}

The class vtkWarpTransform has several methods that can be used.
  They are listed below.
Note that the documentation is translated automatically from the VTK sources,
and may not be completely intelligible.  When in doubt, consult the VTK website.
In the methods listed below, \verb|obj| is an instance of the vtkWarpTransform class.
\begin{itemize}
\item  \verb|string = obj.GetClassName ()|

\item  \verb|int = obj.IsA (string name)|

\item  \verb|vtkWarpTransform = obj.NewInstance ()|

\item  \verb|vtkWarpTransform = obj.SafeDownCast (vtkObject o)|

\item  \verb|obj.Inverse ()| -  Invert the transformation.  Warp transformations are usually
 inverted using an iterative technique such as Newton's method.
 The inverse transform is usually around five or six times as
 computationally expensive as the forward transform.

\item  \verb|int = obj.GetInverseFlag ()| -  Get the inverse flag of the transformation.  This flag is
 set to zero when the transformation is first created, and
 is flipped each time Inverse() is called.

\item  \verb|obj.SetInverseTolerance (double )| -  Set the tolerance for inverse transformation.
 The default is 0.001.

\item  \verb|double = obj.GetInverseTolerance ()| -  Set the tolerance for inverse transformation.
 The default is 0.001.

\item  \verb|obj.SetInverseIterations (int )| -  Set the maximum number of iterations for the inverse
 transformation.  The default is 500, but usually only 
 2 to 5 iterations are used.  The inversion method
 is fairly robust, and it should converge for nearly all smooth
 transformations that do not fold back on themselves.

\item  \verb|int = obj.GetInverseIterations ()| -  Set the maximum number of iterations for the inverse
 transformation.  The default is 500, but usually only 
 2 to 5 iterations are used.  The inversion method
 is fairly robust, and it should converge for nearly all smooth
 transformations that do not fold back on themselves.

\item  \verb|obj.InternalTransformPoint (float in[3], float out[3])| -  This will calculate the transformation without calling Update.
 Meant for use only within other VTK classes.

\item  \verb|obj.InternalTransformPoint (double in[3], double out[3])| -  This will calculate the transformation without calling Update.
 Meant for use only within other VTK classes.

\item  \verb|obj.TemplateTransformPoint (float in[3], float out[3])| -  Do not use these methods.  They exists only as a work-around for
 internal templated functions (I really didn't want to make the
 Forward/Inverse methods public, is there a decent work around
 for this sort of thing?)

\item  \verb|obj.TemplateTransformPoint (double in[3], double out[3])| -  Do not use these methods.  They exists only as a work-around for
 internal templated functions (I really didn't want to make the
 Forward/Inverse methods public, is there a decent work around
 for this sort of thing?)

\item  \verb|obj.TemplateTransformInverse (float in[3], float out[3])| -  Do not use these methods.  They exists only as a work-around for
 internal templated functions (I really didn't want to make the
 Forward/Inverse methods public, is there a decent work around
 for this sort of thing?)

\item  \verb|obj.TemplateTransformInverse (double in[3], double out[3])| -  Do not use these methods.  They exists only as a work-around for
 internal templated functions (I really didn't want to make the
 Forward/Inverse methods public, is there a decent work around
 for this sort of thing?)

\end{itemize}
