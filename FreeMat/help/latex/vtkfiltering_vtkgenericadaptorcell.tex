\section{vtkGenericAdaptorCell}

\subsection{Usage}

 In VTK, spatial-temporal data is defined in terms of a dataset which is
 composed of cells. The cells are topological entities over which an 
 interpolation field is applied. Cells are defined in terms of a topology
 (e.g., vertices, lines, triangles, polygons, tetrahedra, etc.), points
 that instantiate the geometry of the cells, and interpolation fields
 (in the general case one interpolation field is for geometry, the other
 is for attribute data associated with the cell).

 Currently most algorithms in VTK use vtkCell and vtkDataSet, which make 
 assumptions about the nature of datasets, cells, and attributes. In
 particular, this abstraction assumes that cell interpolation functions
 are linear, or products of linear functions. Further, VTK implements
 most of the interpolation functions. This implementation starts breaking
 down as the complexity of the interpolation (or basis) functions
 increases. 

 vtkGenericAdaptorCell addresses these issues by providing more general
 abstraction for cells. It also adopts modern C++ practices including using
 iterators. The vtkGenericAdaptorCell is designed to fit within the adaptor
 framework; meaning that it is meant to adapt VTK to external simulation
 systems (see the GenericFiltering/README.html).

 Please note that most cells are defined in terms of other cells (the
 boundary cells). They are also defined in terms of points, which are
 not the same as vertices (vertices are a 0-D cell; points represent a
 position in space).

 Another important concept is the notion of DOFNodes. These concept
 supports cell types with complex interpolation functions. For example,
 higher-order p-method finite elements may have different functions on each
 of their topological features (edges, faces, region). The coefficients of
 these polynomial functions are associated with DOFNodes. (There is a
 single DOFNode for each topological feature.) Note that from this
 perspective, points are used to establish the topological form of the 
 cell; mid-side nodes and such are considered DOFNodes.

To create an instance of class vtkGenericAdaptorCell, simply
invoke its constructor as follows
\begin{verbatim}
  obj = vtkGenericAdaptorCell
\end{verbatim}
\subsection{Methods}

The class vtkGenericAdaptorCell has several methods that can be used.
  They are listed below.
Note that the documentation is translated automatically from the VTK sources,
and may not be completely intelligible.  When in doubt, consult the VTK website.
In the methods listed below, \verb|obj| is an instance of the vtkGenericAdaptorCell class.
\begin{itemize}
\item  \verb|string = obj.GetClassName ()|

\item  \verb|int = obj.IsA (string name)|

\item  \verb|vtkGenericAdaptorCell = obj.NewInstance ()|

\item  \verb|vtkGenericAdaptorCell = obj.SafeDownCast (vtkObject o)|

\item  \verb|vtkIdType = obj.GetId ()| -  Unique identification number of the cell over the whole
 data set. This unique key may not be contiguous.

\item  \verb|int = obj.IsInDataSet ()| -  Does `this' a cell of a dataset? (otherwise, it is a boundary cell)

\item  \verb|int = obj.GetType ()| -  Return the type of the current cell.
 
       (result==VTK\_HIGHER\_ORDER\_TRIANGLE)||
       (result==VTK\_HIGHER\_ORDER\_TETRAHEDRON)

\item  \verb|int = obj.GetDimension ()| -  Return the topological dimension of the current cell.
 

\item  \verb|int = obj.GetGeometryOrder ()| -  Return the interpolation order of the geometry.
 

\item  \verb|int = obj.IsGeometryLinear ()| -  Does the cell have a non-linear interpolation for the geometry?
 

\item  \verb|int = obj.GetAttributeOrder (vtkGenericAttribute a)| -  Return the interpolation order of attribute `a' on the cell
 (may differ by cell).  
 
 

\item  \verb|int = obj.GetHighestOrderAttribute (vtkGenericAttributeCollection ac)| -  Return the index of the first point centered attribute with the highest
 order in `ac'.
 
 

\item  \verb|int = obj.IsAttributeLinear (vtkGenericAttribute a)| -  Does the attribute `a' have a non-linear interpolation?
 
 

\item  \verb|int = obj.IsPrimary ()| -  Is the cell primary (i.e. not composite) ?

\item  \verb|int = obj.GetNumberOfPoints ()| -  Return the number of corner points that compose the cell.
 

\item  \verb|int = obj.GetNumberOfBoundaries (int dim)| -  Return the number of boundaries of dimension `dim' (or all dimensions
 greater than 0 and less than GetDimension() if -1) of the cell.
 When  dim is -1, the number of vertices is not included in the
 count because vertices are a special case: a vertex will have
 at most a single field value associated with it; DOF nodes may have
 an arbitrary number of field values associated with them.
 
 

\item  \verb|int = obj.GetNumberOfDOFNodes ()| -  Accumulated number of DOF nodes of the current cell. A DOF node is
 a component of cell with a given topological dimension. e.g.: a triangle
 has 4 DOF: 1 face and 3 edges. An hexahedron has 19 DOF:
 1 region, 6 faces, and 12 edges.

 The number of vertices is not included in the
 count because vertices are a special case: a vertex will have
 at most a single field value associated with it; DOF nodes may have
 an arbitrary number of field values associated with them.
 

\item  \verb|obj.GetPointIterator (vtkGenericPointIterator it)| -  Return the points of cell into `it'.
 

\item  \verb|vtkGenericCellIterator = obj.NewCellIterator ()| -  Create an empty cell iterator. The user is responsible for deleting it.
 

\item  \verb|obj.GetBoundaryIterator (vtkGenericCellIterator boundaries, int dim)| -  Return the `boundaries' cells of dimension `dim' (or all dimensions
 less than GetDimension() if -1) that are part of the boundary of the cell.
 
 

\item  \verb|int = obj.CountNeighbors (vtkGenericAdaptorCell boundary)| -  Number of cells (dimension>boundary->GetDimension()) of the dataset
 that share the boundary `boundary' of `this'.
 `this' IS NOT INCLUDED.
 
 
 
 
 

\item  \verb|obj.CountEdgeNeighbors (int sharing)| -  Number of cells (dimension>boundary->GetDimension()) of the dataset
 that share the boundary `boundary' of `this'.
 `this' IS NOT INCLUDED.
 
 
 
 
 

\item  \verb|obj.GetNeighbors (vtkGenericAdaptorCell boundary, vtkGenericCellIterator neighbors)| -  Put into `neighbors' the cells (dimension>boundary->GetDimension())
 of the dataset that share the boundary `boundary' with this cell.
 `this' IS NOT INCLUDED.
 
 
 
 
 

\item  \verb|obj.EvaluateLocation (int subId, double pcoords[3], double x[3])| -  Determine the global coordinates `x' from sub-cell `subId' and parametric
 coordinates `pcoords' in the cell.
 
 
 \&\&(pcoords[1]<=1)\&\&(0<=pcoords[2])\&\&(pcoords[2]<=1)

\item  \verb|obj.InterpolateTuple (vtkGenericAttribute a, double pcoords[3], double val)| -  Interpolate the attribute `a' at local position `pcoords' of the cell into
 `val'.
 
 
 
                     pcoords[1]<=1 \&\& pcoords[2]>=0 \&\& pcoords[2]<=1
 
 

\item  \verb|obj.InterpolateTuple (vtkGenericAttributeCollection c, double pcoords[3], double val)| -  Interpolate the whole collection of attributes `c' at local position
 `pcoords' of the cell into `val'. Only point centered attributes are
 taken into account.
 
 
                     pcoords[1]<=1 \&\& pcoords[2]>=0 \&\& pcoords[2]<=1
 
 

\item  \verb|obj.Contour (vtkContourValues values, vtkImplicitFunction f, vtkGenericAttributeCollection attributes, vtkGenericCellTessellator tess, vtkIncrementalPointLocator locator, vtkCellArray verts, vtkCellArray lines, vtkCellArray polys, vtkPointData outPd, vtkCellData outCd, vtkPointData internalPd, vtkPointData secondaryPd, vtkCellData secondaryCd)| -  Generate a contour (contouring primitives) for each `values' or with
 respect to an implicit function `f'. Contouring is performed on the
 scalar attribute (`attributes->GetActiveAttribute()'
 `attributes->GetActiveComponent()').  Contouring interpolates the
 `attributes->GetNumberOfattributesToInterpolate()' attributes
 `attributes->GetAttributesToInterpolate()'.  The `locator', `verts',
 `lines', `polys', `outPd' and `outCd' are cumulative data arrays over
 cell iterations: they store the result of each call to Contour():
 - `locator' is a points list that merges points as they are inserted
  (i.e., prevents duplicates).
 - `verts' is an array of generated vertices
 - `lines' is an array of generated lines
 - `polys' is an array of generated polygons
 - `outPd' is an array of interpolated point data along the edge (if
 not-NULL)
 - `outCd' is an array of copied cell data of the current cell (if 
 not-NULL)
 `internalPd', `secondaryPd' and `secondaryCd' are initialized by the
 filter that call it from `attributes'.
 - `internalPd' stores the result of the tessellation pass: the
 higher-order cell is tessellated into linear sub-cells.
 - `secondaryPd' and `secondaryCd' are used internally as inputs to the
 Contour() method on linear sub-cells.
 Note: the CopyAllocate() method must be invoked on both `outPd' and
 `outCd', from `secondaryPd' and `secondaryCd'.

 NOTE: `vtkGenericAttributeCollection *attributes' will be replaced by a
       `vtkInformation'.

 
 
 
 
 
 
 
 
 
 

\item  \verb|obj.Clip (double value, vtkImplicitFunction f, vtkGenericAttributeCollection attributes, vtkGenericCellTessellator tess, int insideOut, vtkIncrementalPointLocator locator, vtkCellArray connectivity, vtkPointData outPd, vtkCellData outCd, vtkPointData internalPd, vtkPointData secondaryPd, vtkCellData secondaryCd)| -  Cut (or clip) the current cell with respect to the contour defined by
 the `value' or the implicit function `f' of the scalar attribute
 (`attributes->GetActiveAttribute()',`attributes->GetActiveComponent()').
 If `f' exists, `value' is not used. The output is the part of the
 current cell which is inside the contour.  The output is a set of zero,
 one or more cells of the same topological dimension as the current
 cell. Normally, cell points whose scalar value is greater than ''value''
 are considered inside. If `insideOut' is on, this is reversed.  Clipping
 interpolates the `attributes->GetNumberOfattributesToInterpolate()'
 attributes `attributes->GetAttributesToInterpolate()'.  `locator',
 `connectivity', `outPd' and `outCd' are cumulative data arrays over cell
 iterations: they store the result of each call to Clip():
 - `locator' is a points list that merges points as they are inserted
 (i.e., prevents duplicates).
 - `connectivity' is an array of generated cells
 - `outPd' is an array of interpolated point data along the edge (if
 not-NULL)
 - `outCd' is an array of copied cell data of the current cell (if
 not-NULL)
 `internalPd', `secondaryPd' and `secondaryCd' are initialized by the
 filter that call it from `attributes'.
 - `internalPd' stores the result of the tessellation pass: the
 higher-order cell is tessellated into linear sub-cells.
 - `secondaryPd' and `secondaryCd' are used internally as inputs to the
 Clip() method on linear sub-cells.
 Note: the CopyAllocate() method must be invoked on both `outPd' and
 `outCd', from `secondaryPd' and `secondaryCd'.

 NOTE: `vtkGenericAttributeCollection *attributes' will be replaced by a
       `vtkInformation'.

 
 
 
 
 
 
 

\item  \verb|obj.Derivatives (int subId, double pcoords[3], vtkGenericAttribute attribute, double derivs)| -  Compute derivatives `derivs' of the attribute `attribute' (from its
 values at the corner points of the cell) given sub-cell `subId' (0 means
 primary cell) and parametric coordinates `pcoords'.
 Derivatives are in the x-y-z coordinate directions for each data value.
 
 
 \&\&(pcoords[1]<=1)\&\&(0<=pcoords[2])%%(pcoords[2]<=1)
 
 
 

\item  \verb|obj.GetBounds (double bounds[6])| -  Compute the bounding box of the current cell in `bounds' in global
 coordinates.
 THREAD SAFE

\item  \verb|double = obj.GetLength2 ()| -  Return the bounding box diagonal squared of the current cell.
 

\item  \verb|int = obj.GetParametricCenter (double pcoords[3])| -  Get the center of the current cell (in parametric coordinates) and place
 it in `pcoords'.  If the current cell is a composite, the return value
 is the sub-cell id that the center is in.  
 (result>=0) \&\& (IsPrimary() implies result==0)

\item  \verb|double = obj.GetParametricDistance (double pcoords[3])| -  Return the distance of the parametric coordinate `pcoords' to the
 current cell.  If inside the cell, a distance of zero is returned. This
 is used during picking to get the correct cell picked. (The tolerance
 will occasionally allow cells to be picked who are not really
 intersected ''inside'' the cell.)  

\item  \verb|obj.Tessellate (vtkGenericAttributeCollection attributes, vtkGenericCellTessellator tess, vtkPoints points, vtkIncrementalPointLocator locator, vtkCellArray cellArray, vtkPointData internalPd, vtkPointData pd, vtkCellData cd, vtkUnsignedCharArray types)| -  Tessellate the cell if it is not linear or if at least one attribute of
 `attributes' is not linear. The output are linear cells of the same
 dimension than the cell. If the cell is linear and all attributes are
 linear, the output is just a copy of the current cell.
 `points', `cellArray', `pd' and `cd' are cumulative output data arrays
 over cell iterations: they store the result of each call to Tessellate().
 `internalPd' is initialized by the calling filter and stores the
 result of the tessellation.
 If it is not null, `types' is filled with the types of the linear cells.
 `types' is null when it is called from vtkGenericGeometryFilter and not
 null when it is called from vtkGenericDatasetTessellator.
 
 
 
 
 
 
 

\item  \verb|int = obj.IsFaceOnBoundary (vtkIdType faceId)| -  Is the face `faceId' of the current cell on the exterior boundary of the
 dataset?
 

\item  \verb|int = obj.IsOnBoundary ()| -  Is the cell on the exterior boundary of the dataset?
 

\item  \verb|obj.TriangulateFace (vtkGenericAttributeCollection attributes, vtkGenericCellTessellator tess, int index, vtkPoints points, vtkIncrementalPointLocator locator, vtkCellArray cellArray, vtkPointData internalPd, vtkPointData pd, vtkCellData cd)| -  Tessellate face `index' of the cell. See Tessellate() for further
 explanations.
 
 
 
 
 
 
 
 
 

\item  \verb|int = obj.GetNumberOfVerticesOnFace (int faceId)| -  Return the number of vertices defining face `faceId'.
 
 
 

\end{itemize}
