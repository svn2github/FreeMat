\section{vtkDistributedDataFilter}

\subsection{Usage}

 This filter redistributes data among processors in a parallel
 application into spatially contiguous vtkUnstructuredGrids.
 The execution model anticipated is that all processes read in
 part of a large vtkDataSet. Each process sets the input of
 filter to be that DataSet. When executed, this filter builds
 in parallel a k-d tree, decomposing the space occupied by the
 distributed DataSet into spatial regions.  It assigns each
 spatial region to a processor.  The data is then redistributed
 and the output is a single vtkUnstructuredGrid containing the
 cells in the process' assigned regions.

 This filter is sometimes called ''D3'' for ''distributed data decomposition''.

 Enhancement: You can set the k-d tree decomposition, rather than
 have D3 compute it.  This allows you to divide a dataset using
 the decomposition computed for another dataset.  Obtain a description
 of the k-d tree cuts this way:

    vtkBSPCuts *cuts = D3Object1->GetCuts()

 And set it this way:

    D3Object2->SetCuts(cuts) 

    It is desirable to have a field array of global node IDs
    for two reasons:

    1. When merging together sub grids that were distributed
    across processors, global node IDs can be used to remove
    duplicate points and significantly reduce the size of the
    resulting output grid.  If no such array is available,
    D3 will use a tolerance to merge points, which is much
    slower.

    2. If ghost cells have been requested, D3 requires a
    global node ID array in order to request and transfer
    ghost cells in parallel among the processors.  If there
    is no global node ID array, D3 will in parallel create
    a global node ID array, and the time to do this can be
    significant.
    
    If you know the name of a global node ID array in the input
    dataset, set that name with this method.  If you leave
    it unset, D3 will search the input data set for certain
    common names of global node ID arrays.  If none is found,
    and ghost cells have been requested, D3 will create a
    temporary global node ID array before aquiring ghost cells.
   It is also desirable to have global element IDs.  However,
   if they don't exist D3 can create them relatively quickly.
   Set the name of the global element ID array if you have it.
   If it is not set, D3 will search for it using common names.
   If still not found, D3 will create a temporary array of
   global element IDs.


To create an instance of class vtkDistributedDataFilter, simply
invoke its constructor as follows
\begin{verbatim}
  obj = vtkDistributedDataFilter
\end{verbatim}
\subsection{Methods}

The class vtkDistributedDataFilter has several methods that can be used.
  They are listed below.
Note that the documentation is translated automatically from the VTK sources,
and may not be completely intelligible.  When in doubt, consult the VTK website.
In the methods listed below, \verb|obj| is an instance of the vtkDistributedDataFilter class.
\begin{itemize}
\item  \verb|string = obj.GetClassName ()|

\item  \verb|int = obj.IsA (string name)|

\item  \verb|vtkDistributedDataFilter = obj.NewInstance ()|

\item  \verb|vtkDistributedDataFilter = obj.SafeDownCast (vtkObject o)|

\item  \verb|obj.SetController (vtkMultiProcessController c)| -    Set/Get the communicator object

\item  \verb|vtkMultiProcessController = obj.GetController ()| -    Set/Get the communicator object

\item  \verb|vtkPKdTree = obj.GetKdtree ()|

\item  \verb|obj.RetainKdtreeOn ()|

\item  \verb|obj.RetainKdtreeOff ()|

\item  \verb|int = obj.GetRetainKdtree ()|

\item  \verb|obj.SetRetainKdtree (int )|

\item  \verb|obj.IncludeAllIntersectingCellsOn ()|

\item  \verb|obj.IncludeAllIntersectingCellsOff ()|

\item  \verb|int = obj.GetIncludeAllIntersectingCells ()|

\item  \verb|obj.SetIncludeAllIntersectingCells (int )|

\item  \verb|obj.ClipCellsOn ()|

\item  \verb|obj.ClipCellsOff ()|

\item  \verb|int = obj.GetClipCells ()|

\item  \verb|obj.SetClipCells (int )|

\item  \verb|obj.SetBoundaryMode (int mode)| -  Handling of ClipCells and IncludeAllIntersectingCells.

\item  \verb|obj.SetBoundaryModeToAssignToOneRegion ()| -  Handling of ClipCells and IncludeAllIntersectingCells.

\item  \verb|obj.SetBoundaryModeToAssignToAllIntersectingRegions ()| -  Handling of ClipCells and IncludeAllIntersectingCells.

\item  \verb|obj.SetBoundaryModeToSplitBoundaryCells ()| -  Handling of ClipCells and IncludeAllIntersectingCells.

\item  \verb|int = obj.GetBoundaryMode ()| -  Handling of ClipCells and IncludeAllIntersectingCells.

\item  \verb|obj.UseMinimalMemoryOn ()|

\item  \verb|obj.UseMinimalMemoryOff ()|

\item  \verb|int = obj.GetUseMinimalMemory ()|

\item  \verb|obj.SetUseMinimalMemory (int )|

\item  \verb|obj.TimingOn ()|

\item  \verb|obj.TimingOff ()|

\item  \verb|obj.SetTiming (int )|

\item  \verb|int = obj.GetTiming ()|

\item  \verb|vtkBSPCuts = obj.GetCuts ()| -  You can set the k-d tree decomposition, rather than
 have D3 compute it.  This allows you to divide a dataset using
 the decomposition computed for another dataset.  Obtain a description
 of the k-d tree cuts this way:

    vtkBSPCuts *cuts = D3Object1->GetCuts()

 And set it this way:

    D3Object2->SetCuts(cuts) 

\item  \verb|obj.SetCuts (vtkBSPCuts cuts)| -  You can set the k-d tree decomposition, rather than
 have D3 compute it.  This allows you to divide a dataset using
 the decomposition computed for another dataset.  Obtain a description
 of the k-d tree cuts this way:

    vtkBSPCuts *cuts = D3Object1->GetCuts()

 And set it this way:

    D3Object2->SetCuts(cuts) 

\end{itemize}
