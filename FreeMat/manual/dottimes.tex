% Copyright (c) 2002, 2003 Samit Basu
%
% Permission is hereby granted, free of charge, to any person obtaining a 
% copy of this software and associated documentation files (the "Software"), 
% to deal in the Software without restriction, including without limitation 
% the rights to use, copy, modify, merge, publish, distribute, sublicense, 
% and/or sell copies of the Software, and to permit persons to whom the 
% Software is furnished to do so, subject to the following conditions:
%
% The above copyright notice and this permission notice shall be included 
% in all copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
% OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
% FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
% DEALINGS IN THE SOFTWARE.
\subsection{DOTTIMES Element-wise Multiplication Operator}
\subsubsection{Usage}
Multiplies two numerical arrays (elementwise).  There are two forms
for its use, both with the same general syntax:
\begin{verbatim}
  y = a .* b
\end{verbatim}
where $a$ and $b$ are $n$-dimensional arrays of numerical type.  In the
first case, the two arguments are the same size, in which case, the 
output $y$ is the same size as the inputs, and is the element-wise
product of $a$ and $b$.  In the second case, either $a$ or $b$ is a scalar, 
in which case $y$ is the same size as the larger argument,
and is the product of the scalar with each element of the other argument.

The type of $y$ depends on the types of $a$ and $b$ using type 
promotion rules. All of the types are preserved under multiplication except
 for integer types, which are promoted to \verb|int32| prior to 
multiplication (same as \verb|C|).
\subsubsection{Function Internals}
There are three formulae for the dot-times operator, depending on the
sizes of the three arguments.  In the most general case, in which 
the two arguments are the same size, the output is computed via:
\[
y(m_1,\ldots,m_d) = a(m_1,\ldots,m_d) \times b(m_1,\ldots,m_d)
\]
If $a$ is a scalar, then the output is computed via
\[
y(m_1,\ldots,m_d) = a \times b(m_1,\ldots,m_d).
\]
On the other hand, if $b$ is a scalar, then the output is computed via
\[
y(m_1,\ldots,m_d) = a(m_1,\ldots,m_d) \times b.
\]
\subsubsection{Examples}
Here are some examples of using the dottimes operator.  First, a 
straight-forward usage of the \verb|.*| operator.  The first example
is straightforward:
\begin{verbatim}
--> 3 .* 8
ans =
  <int32>  - size: [1 1]
            24
\end{verbatim}
Note, however, that because of the way that input is parsed, eliminating
the spaces \verb|3.*8| results in the input being parsed as \verb|3. * 8|,
which yields a \verb|double| result:
\begin{verbatim}
--> 3.*8
ans =
  <double>  - size: [1 1]
   24.0000000000000
\end{verbatim}
This is really an invokation of the \verb|times| operator.

Next, we use the floating point syntax to force one of the arguments
to be a \verb|double|, which results in the output being \verb|double|:
\begin{verbatim}
--> 3.1 .* 2
ans =
  <double>  - size: [1 1]
    6.200000000000000
\end{verbatim}
Note that if one of the arguments is complex-valued, the output will be
complex also.
\begin{verbatim}
--> a = 3 + 4*i
a =
  <complex>  - size: [1 1]
    3.0000000         4.0000000     i
--> b = a .* 2.0f
b =
  <complex>  - size: [1 1]
    6.0000000         8.0000000     i
\end{verbatim}
If a \verb|complex| value is multiplied by a \verb|double|, the result is 
promoted to \verb|dcomplex|.
\begin{verbatim}
--> b = a .* 2.0
b =
  <dcomplex>  - size: [1 1]
    6.000000000000000        8.000000000000000    i
\end{verbatim}
We can also demonstrate the three forms of the dottimes operator.  First
the element-wise version:
\begin{verbatim}
--> a = [1,2;3,4]
a =
  <int32>  - size: [2 2]
  
Columns 1 to 2
             1              2
             3              4
--> b = [2,3;6,7]
b =
  <int32>  - size: [2 2]
  
Columns 1 to 2
             2              3
             6              7
--> c = a .* b
c =
  <int32>  - size: [2 2]
  
Columns 1 to 2
             2              6
            18             28
\end{verbatim}
Then the scalar versions
\begin{verbatim}
--> c = a .* 3
c =
  <int32>  - size: [2 2]
  
Columns 1 to 2
             3              6
             9             12
--> c = 3 .* a
c =
  <int32>  - size: [2 2]
  
Columns 1 to 2
             3              6
             9             12
\end{verbatim}
