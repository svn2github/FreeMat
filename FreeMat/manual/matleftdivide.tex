% Copyright (c) 2002, 2003 Samit Basu
%
% Permission is hereby granted, free of charge, to any person obtaining a 
% copy of this software and associated documentation files (the "Software"), 
% to deal in the Software without restriction, including without limitation 
% the rights to use, copy, modify, merge, publish, distribute, sublicense, 
% and/or sell copies of the Software, and to permit persons to whom the 
% Software is furnished to do so, subject to the following conditions:
%
% The above copyright notice and this permission notice shall be included 
% in all copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
% OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
% FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
% DEALINGS IN THE SOFTWARE.
\subsection{LEFTDIVIDE Matrix Equation Solver/Divide Operator}
\subsubsection{Usage}
The divide operator \verb|\| is really a combination of three
operators, all of which have the same general syntax:
\begin{verbatim}
  Y = A \ B
\end{verbatim}
where $A$ and $B$ are arrays of numerical type.  The result $Y$ depends
on which of the following three situations applies to the arguments
$A$ and $B$:
\begin{enumerate}
  \item $A$ is a scalar, $B$ is an arbitrary $n$-dimensional numerical array, in which case the output is each element of $B$ divided by the scalar $A$.
  \item $B$ is a scalar, $A$ is an arbitrary $n$-dimensional numerical array, in which case the output is the scalar $B$ divided by each element of $A$.
  \item $A,B$ are matrices with the same number of rows, i.e., $A$ is of size $M \times K$, and $B$ is of size $M \times L$, in which case the output is of size $K \times L$.
\end{enumerate}
The output follows the standard type promotion rules, although in the first two cases, if $A$ and $B$ are integers, the output is an integer also, while in the third case if $A$ and $B$ are integers, the output is of type \verb|double|.

A few additional words about the third version, in which $A$ and $B$ are matrices.  Very loosely speaking, $Y$ is the matrix that satisfies $A * Y = B$.  In cases where such a matrix exists.  If such a matrix does not exist, then a matrix $Y$ is returned that approximates $A * Y \approx B$.
\subsubsection{Function Internals}
There are three formulae for the times operator.  For the first form
\[
Y(m_1,\ldots,m_d) = \frac{B(m_1,\ldots,m_d)}{A},
\]
and the second form
\[
Y(m_1,\ldots,m_d) = \frac{B}{A(m_1,\ldots,m_d)}.
\]
In the third form, the calculation of the output depends on the size of $A$. Because each column of $B$ is treated independantly, we can rewrite the equation $A Y = B$ as
\[
  A [y_1, y_2,\ldots, y_l] = [b_1, b_2, \ldots, b_l]
\]
where $y_i$ are the columns of $Y$, and $b_i$ are the columns of the matrix $B$.If $A$ is a square matrix, then the LAPACK routine \verb|*gesvx| (where the \verb|*| is replaced with \verb|sdcz| depending on the type of the arguments) is used, which uses an LU decomposition of $A$ to solve the sequence of equations sequentially.  If $A$ is singular, then a warning is emitted. 

On the other hand, if $A$ is rectangular, then the LAPACK routine \verb|*gelsy| is used.  Note that these routines are designed to work with matrices $A$ that are full rank - either full column rank or full row rank.  If $A$ fails to satisfy this assumption, a warning is emitted.  If $A$ has full column rank (and thus necessarily has more rows than columns), then theoretically, this operator finds the columns $y_i$ that satisfy:
\[
  y_i = \arg \min_y \| A y - b_i \|_2
\]
and each column is thus the Least Squares solution of $A y = b_i$.  On the other hand, if $A$ has full row rank (and thus necessarily has more columns than rows), then theoretically, this operator finds the columns $y_i$ that satisfy
\[
  y_i = \arg \min_{A y = b_i} \| y \|_2
\]
and each column is thus the Minimum Norm vector $y_i$ that satisfies $A y_i = b_i$.  
In the event that the matrix $A$ is neither full row rank nor full column rank, a solution is returned, that is the minimum norm least squares solution.  The solution is computed using an orthogonal factorization technique that is documented in the LAPACK User's Guide (see the References section for details).
\subsubsection{Examples}
Here are some simple examples of the divide operator.  We start with a simple example of a full rank, square matrix:
\begin{verbatim}
--> A = [1,1;0,1]
A =
  <int32>  - size: [2 2]
  
Columns 1 to 2
             1              1
             0              1
\end{verbatim}
Suppose we wish to solve
\[
  \begin{bmatrix} 1 & 1 \\ 0 & 1 \end{bmatrix}
  \begin{bmatrix} y_1 \\ y_2 \end{bmatrix}
 = 
  \begin{bmatrix} 3 \\ 2 \end{bmatrix}
\]
(which by inspection has the solution $y_1 = 1$, $y_2 = 2$).  Thus we compute:
\begin{verbatim}
--> B = [3;2]
B =
  <int32>  - size: [2 1]
  
Columns 1 to 1
             3
             2
--> Y = A\B
Y =
  <double>  - size: [2 1]
  
Columns 1 to 1
    1.000000000000000
    2.000000000000000
\end{verbatim}

Suppose we wish to solve a trivial Least Squares (LS) problem.  We want to find a simple scaling of the vector $[1;1]$ that is closest to the point $[2,1]$.  This is equivalent to solving
\[
\begin{bmatrix} 1 \\ 1 \end{bmatrix} y = \begin{bmatrix} 2 \\ 1 \end{bmatrix}
\]
in a least squares sense.  For fun, we can calculate the solution using calculus by hand.  The error $\varepsilon(y)$ we wish to minimize is
\[
  \varepsilon(y) = (y - 2)^2 + (y-1)^2.
\]
Taking a derivative with respect to $y$, and setting to zero (which we must have for an extrema when $y$ is unconstrained)
\[
  2 (y-2) + 2 (y-1) = 0
\]
which we can simplify to $4y = 6$ or $y = 3/2$ (we must, technically, check to make sure this is a minimum, and not a maximum or an inflection point).  Here is the same calculation performed using FreeMat:
\begin{verbatim}
--> A = [1;1]
A =
  <int32>  - size: [2 1]
  
Columns 1 to 1
             1
             1
--> B = [2;1]
B =
  <int32>  - size: [2 1]
  
Columns 1 to 1
             2
             1
--> A\B
ans =
  <double>  - size: [1 1]
    1.500000000000000
\end{verbatim}
which is the same solution.
