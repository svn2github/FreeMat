First pass - we want to run FreeMat on a cluster, and use rserver...

1.  In principle, we need:
    A. An option that allows the kernel to run the rserver,
       so that we can issue something like:

ssh gn0 'FMKernel -e rserver'
ssh gn1 'FMKernel -e rserver'
ssh gn2 'FMKernel -e rserver'
...
ssh gnM 'FMKernel -e rserver'

    B. A select mechanism that allows you to wait for 
       computations to complete

Second pass - a virtual file system would be nice - but its not
critical...

Back to the first pass.  One issue is that we need to determine 
a port number that can be used.  If the spawning is under FreeMat
control, we can do something like:

ssh gn0 'FMKernel -e rserver 44067'

That means we need FreeMat strings with embeddable quotes.

That's done.

We also need an argument that allows you to execute a command from the cmd
line.
 
A better approach is to integrate MPI into the thing from the outset...  That way, the
user can use lamboot to set up the cluster, and then, once it is running, can start a
FreeMat session in it.  We then need a way for FreeMat to start FMKernel on the various
nodes (unless mpiexec can do it).

What are the issues:

1.  mpiexec or schemas can be used to start up FreeMat on the host (say), and FMKernel on
each of the nodes.  Although I suspect a better approach would be to have MPI-enabled binaries
that called MPI_Init appropriately - FreeMatMPI and FMKernelMPI, say. For FMKernel, this is
OK, as it is a C++ program and has access to the usual argc, argv elements.  But what about
FreeMat?  That will work also - there are argc and argv arguments to wxApp that can be used.

2.  OK, so there are now two MPI-enabled binaries, FreeMatMPI and FMKernel.  What next?
We need bindings to the MPI commands, such as Recv, Send, Broadcast, etc. 
