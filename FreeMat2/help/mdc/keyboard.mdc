KEYBOARD Initiate Interactive Debug Session

USAGE

The keyboard statement is used to initiate an
interactive session at a specific point in a function.
The general syntax for the keyboard statement is

   keyboard

A keyboard statement can be issued in a script,
in a function, or from within another keyboard session.
The result of a keyboard statement is that execution
of the program is halted, and you are given a prompt
of the form:

 [scope,n] -->

where scope is the current scope of execution (either
the name of the function we are executing, or base otherwise).
And n is the depth of the keyboard session. If, for example,
we are in a keyboard session, and we call a function that issues
another keyboard session, the depth of that second session 
will be one higher.  Put another way, n is the number of return
statements you have to issue to get back to the base workspace.
Incidentally, a return is how you exit the keyboard session
and resume execution of the program from where it left off.  A
retall can be used to shortcut execution and return to the base
workspace.

The keyboard statement is an excellent tool for debugging
FreeMat code, and along with eval provide a unique set of
capabilities not usually found in compiled environments.  Indeed,
the keyboard statement is equivalent to a debugger breakpoint in 
more traditional environments, but with significantly more inspection
power.

EXAMPLE

Here we demonstrate a two-level keyboard situation.  We have
a simple function that calls keyboard internally:

$
 *** key_one.m
function c = key_one(a,b)
c = a + b;
keyboard
$

Now, we execute the function from the base workspace, and
at the keyboard prompt, we call it again.  This action
puts us at depth 2.  We can confirm that we are in the second
invocation of the function by examining the arguments.  We
then issue two return statements to return to the base
workspace.

$
--> key_one(1,2)
[key_one,1] --> key_one(5,7)
[key_one,2] --> a
ans = 
  <int32>  - size: [1 1]
             5  
[key_one,2] --> b
ans = 
  <int32>  - size: [1 1]
             7  
[key_one,2] --> c
ans = 
  <int32>  - size: [1 1]
            12  
[key_one,2] --> return
ans = 
  <int32>  - size: [1 1]
            12  
[key_one,1] --> a
ans = 
  <int32>  - size: [1 1]
             1  
[key_one,1] --> b
ans = 
  <int32>  - size: [1 1]
             2  
[key_one,1] --> c
ans = 
  <int32>  - size: [1 1]
             3  
[key_one,1] --> return
ans = 
  <int32>  - size: [1 1]
             3  
$

  