PLUS Addition Operator

USAGE

Adds two numerical arrays (elementwise) together.  There are two forms
for its use, both with the same general syntax:

  y = a + b

where a and b are n-dimensional arrays of numerical type.  In the
first case, the two arguments are the same size, in which case, the 
output y is the same size as the inputs, and is the element-wise the sum 
of a and b.  In the second case, either a or b is a scalar, 
in which case y is the same size as the larger argument,
and is the sum of the scalar added to each element of the other argument.

The type of y depends on the types of a and b using the type 
promotion rules.  The types are ordered as:
\begin{enumerate}

* uint8 - unsigned, 8-bit integers range [0,255]

* int8 - signed, 8-bit integers [-127,128]

* uint16 - unsigned, 16-bit integers [0,65535]

* int16 - signed, 16-bit integers [-32768,32767]

* uint32 - unsigned, 32-bit integers [0,4294967295]

* int32 - signed, 32-bit integers [-2147483648,2147483647]

* float - 32-bit floating point

* double - 64-bit floating point

* complex - 32-bit complex floating point

* dcomplex - 64-bit complex floating point
\end{enumerate}
Note that the type promotion and combination rules work similar to 
C.  Numerical overflow rules are also the same as C.

FUNCTION INTERNALS

There are three formulae for the addition operator, depending on the
sizes of the three arguments.  In the most general case, in which 
the two arguments are the same size, the output is computed via:

$
y(m_1,\ldots,m_d) = a(m_1,\ldots,m_d) + b(m_1,\ldots,m_d)
$

If a is a scalar, then the output is computed via

$
y(m_1,\ldots,m_d) = a + b(m_1,\ldots,m_d).
$

On the other hand, if b is a scalar, then the output is computed via

$
y(m_1,\ldots,m_d) = a(m_1,\ldots,m_d) + b.
$


EXAMPLES

Here are some examples of using the addition operator.  First, a 
straight-forward usage of the plus operator.  The first example
is straightforward - the int32 is the default type used for
integer constants (same as in C), hence the output is the
same type:

$
--> 3 + 8
ans = 
  <int32>  - size: [1 1]
            11  
$

Next, we use the floating point syntax to force one of the arguments
to be a double, which results in the output being double:

$
--> 3.1 + 2
ans = 
  <double>  - size: [1 1]
    5.100000000000000      
$

Note that if one of the arguments is complex-valued, the output will be
complex also.

$
--> a = 3 + 4*i
a = 
  <complex>  - size: [1 1]
    3.0000000         4.0000000     i  
--> b = a + 2.0f
b = 
  <complex>  - size: [1 1]
    5.0000000         4.0000000     i  
$

If a complex value is added to a double, the result is 
promoted to dcomplex.

$
--> b = a + 2.0
b = 
  <dcomplex>  - size: [1 1]
    5.000000000000000        4.000000000000000    i  
$

We can also demonstrate the three forms of the addition operator.  First
the element-wise version:

$
--> a = [1,2;3,4]
a = 
  <int32>  - size: [2 2]
 
Columns 1 to 2
             1              2  
             3              4  
--> b = [2,3;6,7]
b = 
  <int32>  - size: [2 2]
 
Columns 1 to 2
             2              3  
             6              7  
--> c = a + b
c = 
  <int32>  - size: [2 2]
 
Columns 1 to 2
             3              5  
             9             11  
$

Then the scalar versions

$
--> c = a + 1
c = 
  <int32>  - size: [2 2]
 
Columns 1 to 2
             2              3  
             4              5  
--> c = 1 + b
c = 
  <int32>  - size: [2 2]
 
Columns 1 to 2
             3              4  
             7              8  
$

  