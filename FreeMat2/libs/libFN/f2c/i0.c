/* ../i0.f -- translated by f2c (version 20031025).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/

#include "f2c.h"

/* Subroutine */ int calci0_(real *arg, real *result, integer *jint)
{
    /* Initialized data */

    static real one = 1.f;
    static real p[15] = { -5.24878666279456998e-18f,
	    -1.5982226675653184646e-14f,-2.6843448573468483278e-11f,
	    -3.0517226450451067446e-8f,-2.5172644670688975051e-5f,
	    -.015453977791786851041f,-7.093534744921054919f,
	    -2412.5195876041896775f,-595456.26019847898221f,
	    -103130667.08737980747f,-11912746104.985237192f,
	    -849251012471.14157499f,-32940087627407.749166f,
	    -550503696730184.27753f,-2233558263947437.5249f };
    static real q[5] = { -3727.7560179962773046f,6515850.6418655165707f,
	    -6562656074.0833869295f,3760418870409.2954661f,
	    -970879461795940.19126f };
    static real pp[8] = { -.3984375f,2.9205384596336793945f,
	    -2.4708469169133954315f,.47914889422856814203f,
	    -.003738499192606896915f,-.002680152035332863531f,
	    9.9168777670983678974e-5f,-2.187712818903272673e-6f };
    static real qq[7] = { -31.4466902751354915f,85.5395632580129296f,
	    -60.228002066743340583f,13.982595353892851542f,
	    -1.1151759188741312645f,.032547697594819615062f,
	    -5.5194330231005480228e-4f };
    static real one5 = 15.f;
    static real exp40 = 235385266837019985.4f;
    static real forty = 40.f;
    static real rec15 = .066666666666666666666f;
    static real two25 = 225.f;
    static real xsmall = 2.98e-8f;
    static real xinf = 3.4e38f;
    static real xmax = 91.9f;

    /* Builtin functions */
    double exp(doublereal), sqrt(doublereal);

    /* Local variables */
    static real a, b;
    static integer i__;
    static real x, xx, sump, sumq;

/* -------------------------------------------------------------------- */

/* This packet computes modified Bessel functions of the first kind */
/*   and order zero, I0(X) and EXP(-ABS(X))*I0(X), for real */
/*   arguments X.  It contains two function type subprograms, BESI0 */
/*   and BESEI0, and one subroutine type subprogram, CALCI0. */
/*   The calling statements for the primary entries are */

/*                   Y=BESI0(X) */
/*   and */
/*                   Y=BESEI0(X) */

/*   where the entry points correspond to the functions I0(X) and */
/*   EXP(-ABS(X))*I0(X), respectively.  The routine CALCI0 is */
/*   intended for internal packet use only, all computations within */
/*   the packet being concentrated in this routine.  The function */
/*   subprograms invoke CALCI0 with the statement */
/*          CALL CALCI0(ARG,RESULT,JINT) */
/*   where the parameter usage is as follows */

/*      Function                     Parameters for CALCI0 */
/*       Call              ARG                  RESULT          JINT */

/*     BESI0(ARG)    ABS(ARG) .LE. XMAX        I0(ARG)           1 */
/*     BESEI0(ARG)    any real ARG        EXP(-ABS(ARG))*I0(ARG) 2 */

/*   The main computation evaluates slightly modified forms of */
/*   minimax approximations generated by Blair and Edwards, Chalk */
/*   River (Atomic Energy of Canada Limited) Report AECL-4928, */
/*   October, 1974.  This transportable program is patterned after */
/*   the machine-dependent FUNPACK packet NATSI0, but cannot match */
/*   that version for efficiency or accuracy.  This version uses */
/*   rational functions that theoretically approximate I-SUB-0(X) */
/*   to at least 18 significant decimal digits.  The accuracy */
/*   achieved depends on the arithmetic system, the compiler, the */
/*   intrinsic functions, and proper selection of the machine- */
/*   dependent constants. */

/* ******************************************************************* */
/* ******************************************************************* */

/* Explanation of machine-dependent constants */

/*   beta   = Radix for the floating-point system */
/*   maxexp = Smallest power of beta that overflows */
/*   XSMALL = Positive argument such that 1.0 - X = 1.0 to */
/*            machine precision for all ABS(X) .LE. XSMALL. */
/*   XINF =   Largest positive machine number; approximately */
/*            beta**maxexp */
/*   XMAX =   Largest argument acceptable to BESI0;  Solution to */
/*            equation: */
/*               W(X) * (1+1/(8*X)+9/(128*X**2) = beta**maxexp */
/*            where  W(X) = EXP(X)/SQRT(2*PI*X) */


/*     Approximate values for some important machines are: */

/*                          beta       maxexp       XSMALL */

/* CRAY-1        (S.P.)       2         8191       3.55E-15 */
/* Cyber 180/855 */
/*   under NOS   (S.P.)       2         1070       3.55E-15 */
/* IEEE (IBM/XT, */
/*   SUN, etc.)  (S.P.)       2          128       2.98E-8 */
/* IEEE (IBM/XT, */
/*   SUN, etc.)  (D.P.)       2         1024       5.55D-17 */
/* IBM 3033      (D.P.)      16           63       6.95D-18 */
/* VAX           (S.P.)       2          127       2.98E-8 */
/* VAX D-Format  (D.P.)       2          127       6.95D-18 */
/* VAX G-Format  (D.P.)       2         1023       5.55D-17 */


/*                               XINF          XMAX */

/* CRAY-1        (S.P.)       5.45E+2465     5682.810 */
/* Cyber 180/855 */
/*   under NOS   (S.P.)       1.26E+322       745.893 */
/* IEEE (IBM/XT, */
/*   SUN, etc.)  (S.P.)       3.40E+38         91.900 */
/* IEEE (IBM/XT, */
/*   SUN, etc.)  (D.P.)       1.79D+308       713.986 */
/* IBM 3033      (D.P.)       7.23D+75        178.182 */
/* VAX           (S.P.)       1.70D+38         91.203 */
/* VAX D-Format  (D.P.)       1.70D+38         91.203 */
/* VAX G-Format  (D.P.)       8.98D+307       713.293 */

/* ******************************************************************* */
/* ******************************************************************* */

/* Error returns */

/*  The program returns XINF for BESI0 for ABS(ARG) .GT. XMAX. */


/*  Intrinsic functions required are: */

/*     ABS, SQRT, EXP */


/*  Authors: W. J. Cody and L. Stoltz */
/*           Mathematics and Computer Science Division */
/*           Argonne National Laboratory */
/*           Argonne, IL 60439 */

/*  Latest modification: June 7, 1988 */

/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*  Mathematical constants */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*  Machine-dependent constants */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*  Coefficients for XSMALL .LE. ABS(ARG) .LT. 15.0 */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*  Coefficients for 15.0 .LE. ABS(ARG) */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
    x = dabs(*arg);
    if (x < xsmall) {
	*result = one;
    } else if (x < one5) {
/* -------------------------------------------------------------------- */
/*  XSMALL .LE.  ABS(ARG)  .LT. 15.0 */
/* -------------------------------------------------------------------- */
	xx = x * x;
	sump = p[0];
	for (i__ = 2; i__ <= 15; ++i__) {
	    sump = sump * xx + p[i__ - 1];
/* L50: */
	}
	xx -= two25;
	sumq = ((((xx + q[0]) * xx + q[1]) * xx + q[2]) * xx + q[3]) * xx + q[
		4];
	*result = sump / sumq;
	if (*jint == 2) {
	    *result *= exp(-x);
	}
    } else if (x >= one5) {
	if (*jint == 1 && x > xmax) {
	    *result = xinf;
	} else {
/* -------------------------------------------------------------------- */
/*  15.0  .LE.  ABS(ARG) */
/* -------------------------------------------------------------------- */
	    xx = one / x - rec15;
	    sump = ((((((pp[0] * xx + pp[1]) * xx + pp[2]) * xx + pp[3]) * xx 
		    + pp[4]) * xx + pp[5]) * xx + pp[6]) * xx + pp[7];
	    sumq = ((((((xx + qq[0]) * xx + qq[1]) * xx + qq[2]) * xx + qq[3])
		     * xx + qq[4]) * xx + qq[5]) * xx + qq[6];
	    *result = sump / sumq;
	    if (*jint == 2) {
		*result = (*result - pp[0]) / sqrt(x);
	    } else {
/* -------------------------------------------------------------------- */
/*  Calculation reformulated to avoid premature overflow */
/* -------------------------------------------------------------------- */
		if (x <= xmax - one5) {
		    a = exp(x);
		    b = one;
		} else {
		    a = exp(x - forty);
		    b = exp40;
		}
		*result = (*result * a - pp[0] * a) / sqrt(x) * b;
	    }
	}
    }
/* -------------------------------------------------------------------- */
/*  Return for ABS(ARG) .LT. XSMALL */
/* -------------------------------------------------------------------- */
    return 0;
/* ----------- Last line of CALCI0 ----------- */
} /* calci0_ */

doublereal besi0_(real *x)
{
    /* System generated locals */
    real ret_val;

    /* Local variables */
    static integer jint;
    extern /* Subroutine */ int calci0_(real *, real *, integer *);
    static real result;

/* -------------------------------------------------------------------- */

/* This long precision subprogram computes approximate values for */
/*   modified Bessel functions of the first kind of order zero for */
/*   arguments ABS(ARG) .LE. XMAX  (see comments heading CALCI0). */

/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
    jint = 1;
    calci0_(x, &result, &jint);
    ret_val = result;
    return ret_val;
/* ---------- Last line of BESI0 ---------- */
} /* besi0_ */

doublereal besei0_(real *x)
{
    /* System generated locals */
    real ret_val;

    /* Local variables */
    static integer jint;
    extern /* Subroutine */ int calci0_(real *, real *, integer *);
    static real result;

/* -------------------------------------------------------------------- */

/* This function program computes approximate values for the */
/*   modified Bessel function of the first kind of order zero */
/*   multiplied by EXP(-ABS(X)), where EXP is the */
/*   exponential function, ABS is the absolute value, and X */
/*   is any argument. */

/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
    jint = 2;
    calci0_(x, &result, &jint);
    ret_val = result;
    return ret_val;
/* ---------- Last line of BESEI0 ---------- */
} /* besei0_ */

