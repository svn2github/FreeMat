%{
// Copyright (c) 2002, 2003 Samit Basu
// 
// Permission is hereby granted, free of charge, to any person obtaining a 
// copy of this software and associated documentation files (the "Software"), 
// to deal in the Software without restriction, including without limitation 
// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
// and/or sell copies of the Software, and to permit persons to whom the 
// Software is furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.

    /*************************************************************
     * $Source$
     * $Revision$
     * $Date$
     * $Author$
     *************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include "AST.hpp"
#include "WalkTree.hpp"
#include "FunctionDef.hpp"
#include "ParserInterface.hpp"
#include "Exception.hpp"

#define YYDEBUG 1
#define YYSTYPE ParseRHS

#define MSGBUFLEN 2048
static char msgBuffer[MSGBUFLEN];

#include "LexerInterface.hpp"

//extern char* yytext;
extern int yylex(void);

extern int yydebug;
extern const char *parsing_filename;

bool interactiveMode;

#ifdef WIN32
#define snprintf _snprintf
#endif

namespace FreeMat {
  static ASTPtr mainAST;
  static MFunctionDef *mainMDef;

  void yyerror(const char *s) {
     return;
  }

  std::string decodeline(ParseRHS val) {
    int tokenID;
    int linenumber, colnumber;
    if (val.isToken) 
      tokenID = val.v.i;
    else
      tokenID = val.v.p->context();
    linenumber = tokenID & 0xFFFF;
    char buffer[256];
    sprintf(buffer,"%d",linenumber);
    return(std::string(buffer));
  }
  
  int yyxpt(std::string xStr, ParseRHS val) {
    char buffer[256];
    int addone = 1;
    int tokenID;
    int linenumber, colnumber;
    if (val.isToken) 
      tokenID = val.v.i;
    else
      tokenID = val.v.p->context();
    linenumber = tokenID & 0xFFFF;
    colnumber = tokenID >> 16;
    if (!interactiveMode)
      snprintf(msgBuffer,MSGBUFLEN,
      "Expecting %s\n\tat line %d, column %d of file %s",
       xStr.c_str(),linenumber,colnumber,parsing_filename);
    else
      snprintf(msgBuffer,MSGBUFLEN,"Expecting %s",xStr.c_str());
    throw Exception(msgBuffer);
    return 0;
  }
}

using namespace FreeMat;

%}

%token IDENT
%token NUMERIC ENDQSTMNT ENDSTMNT
%token LE GE EQ
%token DOTTIMES DOTRDIV DOTLDIV
%token DOTPOWER DOTTRANSPOSE
%token STRING SPECIALCALL
%token END IF FUNCTION FOR BREAK
%token MAGICEND
%token WHILE ELSE ELSEIF
%token SWITCH CASE OTHERWISE CONTINUE
%token TRY CATCH
%token FIELD REFLPAREN REFRPAREN
%token PERSISTENT
%token KEYBOARD RETURN VARARGIN VARARGOUT GLOBAL
%token QUIT RETALL

%left ':'
%left '|'
%left '&'
%left '<' LE '>' GE EQ NE
%left '+' '-'
%left '*' '/' '\\' DOTTIMES DOTRDIV DOTLDIV
%left POS NEG NOT
%right '^' DOTPOWER
%nonassoc '\'' DOTTRANSPOSE

%%

program:
  statementList {mainAST = $1.v.p;} |
  functionDefList |
  | error {yyxpt("statement list or function definition",$1);}
;

functionDef:
   FUNCTION  returnDeclaration IDENT '(' argumentList ')' newLine statementList {
     MFunctionDef *r;
     r = new MFunctionDef();
     r->returnVals = $2.v.p->toStringList();
     r->name = $3.v.p->text;
     r->arguments = $5.v.p->toStringList();
     r->code = $8.v.p;
     r->fileName = parsing_filename;
     r->nextFunction = NULL;
     if (mainMDef == NULL)
	mainMDef = r;
     else {
	r->localFunction = true;
        r->nextFunction = mainMDef->nextFunction;
	mainMDef->nextFunction = r;
     }
   } |
   FUNCTION  IDENT '(' argumentList ')' newLine statementList {
     MFunctionDef *r;
     r = new MFunctionDef();
     r->name = $2.v.p->text;
     r->arguments = $4.v.p->toStringList();
     r->code = $7.v.p;
     r->fileName = parsing_filename;
     r->nextFunction = NULL;
     if (mainMDef == NULL)
	mainMDef = r;
     else {
	r->localFunction = true;
        r->nextFunction = mainMDef->nextFunction;
	mainMDef->nextFunction = r;
     }
   } |
   FUNCTION  returnDeclaration IDENT newLine statementList {
     MFunctionDef *r;
     r = new MFunctionDef();
     r->returnVals = $2.v.p->toStringList();
     r->name = $3.v.p->text;
     r->code = $5.v.p;
     r->fileName = parsing_filename;
     r->nextFunction = NULL;
     if (mainMDef == NULL)
	mainMDef = r;
     else {
	r->localFunction = true;
        r->nextFunction = mainMDef->nextFunction;
	mainMDef->nextFunction = r;
     }
   } |
   FUNCTION  IDENT newLine statementList {
     MFunctionDef *r;
     r = new MFunctionDef();
     r->name = $2.v.p->text;
     r->code = $4.v.p;
     r->fileName = parsing_filename;
     r->nextFunction = NULL;
     if (mainMDef == NULL)
	mainMDef = r;
     else {
	r->localFunction = true;
        r->nextFunction = mainMDef->nextFunction;
	mainMDef->nextFunction = r;
     }
   } |
   FUNCTION  returnDeclaration IDENT '(' ')' newLine statementList {
     MFunctionDef *r;
     r = new MFunctionDef();
     r->returnVals = $2.v.p->toStringList();
     r->name = $3.v.p->text;
     r->code = $7.v.p;
     r->fileName = parsing_filename;
     r->nextFunction = NULL;
     if (mainMDef == NULL)
	mainMDef = r;
     else {
	r->localFunction = true;
        r->nextFunction = mainMDef->nextFunction;
	mainMDef->nextFunction = r;
     }
   } |
   FUNCTION  IDENT '(' ')' newLine statementList {
     MFunctionDef *r;
     r = new MFunctionDef();
     r->name = $2.v.p->text;
     r->code = $6.v.p;
     r->fileName = parsing_filename;
     r->nextFunction = NULL;
     if (mainMDef == NULL)
	mainMDef = r;
     else {
	r->localFunction = true;
        r->nextFunction = mainMDef->nextFunction;
	mainMDef->nextFunction = r;
     }
   } |
   FUNCTION  error {yyxpt("legal function name or return declaration after 'function'",$1);} |
   FUNCTION  IDENT error {yyxpt(std::string("argument list or statement list after identifier '") + 
	$2.v.p->text + "'",$2);} |
   FUNCTION  IDENT '('  error {yyxpt("(possibly empty) argument list after '('",$3);}  |
   FUNCTION  IDENT '(' argumentList ')' error {yyxpt("statement list after ')'",$5);} |
   FUNCTION  returnDeclaration  error {yyxpt("function name for function declared",$1);} |
   FUNCTION  returnDeclaration IDENT error {yyxpt(std::string("argument list or statement list following function name :") + 
	$3.v.p->text,$3);} |
   FUNCTION  returnDeclaration IDENT '('  error {yyxpt("(possibly empty) argument list after '('",$4);} |
   FUNCTION  returnDeclaration IDENT '(' argumentList ')' error {yyxpt("statement list after ')'",$6);}
  ;

functionDefList:
  functionDef |
  functionDefList functionDef
  ;

returnDeclaration:
  VARARGOUT '=' {$$.v.p = $1.v.p;} |
  IDENT '=' {$$.v.p = $1.v.p;} | 
  '[' argumentList ']' '=' {$$.v.p = $2.v.p;} |
  IDENT error {yyxpt("an '=' symbol after identifier in return declaration",$1);} |
  '[' error {yyxpt("a valid list of return arguments in return declaration",$1);} | 
  '[' argumentList error {yyxpt("matching ']' in return declaration for '['",$1);} |
  '[' argumentList ']' error {yyxpt("an '=' symbol after return declaration",$3);}
  ;

argumentList:
  argument {$$.v.p = $1.v.p;}
  | argumentList ',' argument {$$.v.p = $1.v.p; $$.v.p->addChild($3.v.p);}
  ;

argument:
  IDENT | '&' IDENT {
	$$.v.p = $2.v.p;
	char *b = (char*) malloc(strlen($2.v.p->text)+2);
	b[0] = '&';
	strcpy(b+1,$2.v.p->text);
	$$.v.p->text = b;
  }
  ;
  

statementList:
   statement {$$.v.p = new AST(OP_BLOCK,$1.v.p,$1.v.p->context());} | 
   statementList statement {$$.v.p = $1.v.p; $$.v.p->addChild($2.v.p);}
   ;

statement:
	 statementType ENDQSTMNT {
  	    $$.v.p = new AST(OP_QSTATEMENT,NULL,$2.v.i);
	    $$.v.p->down = $1.v.p;
	 }
	 | statementType ENDSTMNT {
	    $$.v.p = new AST(OP_RSTATEMENT,NULL,$2.v.i);
            $$.v.p->down = $1.v.p;
	 }
	 | statementType ',' {
	    $$.v.p = new AST(OP_RSTATEMENT,NULL,$2.v.i);
	    $$.v.p->down = $1.v.p;
	 } 
	 ;

statementType:
	 assignmentStatement
	 | expr
	 | {$$.v.p = new AST(null_node,"",-1);} 
         | multiFunctionCall
         | forStatement
         | breakStatement
	 | continueStatement
         | whileStatement
       	 | ifStatement
	 | switchStatement
	 | tryStatement
	 | keyboardStatement
	 | returnStatement
	 | globalStatement
	 | persistentStatement
	 | specialSyntaxStatement
	 | QUIT | RETALL 
         ;

specialSyntaxStatement:
	SPECIALCALL stringList {$1.v.p->addChild($2.v.p); 
				$$.v.p = new AST(OP_SCALL,$1.v.p,$1.v.p->context());}
	;

stringList:
	STRING {$$.v.p = new AST(OP_PARENS,$1.v.p,$1.v.p->context());} |
	stringList STRING {$$.v.p = $1.v.p; $$.v.p->addChild($2.v.p);}
	;

persistentStatement:
	PERSISTENT identList {$$.v.p = $1.v.p; $$.v.p->addChild($2.v.p); } |
	PERSISTENT error {yyxpt("list of variables to be tagged as persistent",$1);}
 	;

globalStatement:
	GLOBAL identList {$$.v.p = $1.v.p; $$.v.p->addChild($2.v.p);} |
	GLOBAL error {yyxpt("list of variables to be tagged as global",$1);}
	;

identList:
	IDENT | 
	identList IDENT {$$.v.p = $1.v.p; $$.v.p->addChild($2.v.p);} |
	identList error {yyxpt("list of valid identifiers",$2);}
	;

returnStatement:
	RETURN
	;

keyboardStatement:
	KEYBOARD
	;

continueStatement:
	 CONTINUE
	 ;
breakStatement:
	 BREAK
	 ;

tryStatement:
	TRY  statementList optionalCatch END 
	{ $$.v.p = $1.v.p; $$.v.p->addChild($2.v.p); if ($3.v.p != NULL) $$.v.p->addChild($3.v.p);} 
	| TRY statementList optionalCatch error 
	{yyxpt(std::string("matching 'end' to 'try' clause from line ") + decodeline($1),$4);}
        ;

optionalCatch:
	CATCH statementList {$$.v.p = $2.v.p;}
	| {$$.v.p = NULL;}
	;

switchStatement:
	SWITCH 	expr optionalEndStatement caseBlock otherwiseClause END {
	  $$.v.p = $1.v.p; $$.v.p->addChild($2.v.p); 
	  if ($4.v.p != NULL) $$.v.p->addChild($4.v.p); 
	  if ($5.v.p != NULL) $$.v.p->addChild($5.v.p);
	} |
	SWITCH 	expr optionalEndStatement caseBlock otherwiseClause error {
          yyxpt(std::string("matching 'end' to 'switch' clause from line ") + decodeline($1),$6);
        } 
        ;

optionalEndStatement:
	',' | ENDSTMNT | ENDQSTMNT | ';' | '#'
	;

newLine:
	ENDSTMNT | ENDQSTMNT
	;


caseBlock:
	/* empty */ {$$.v.p = NULL;} |
	caseList
	;

caseList:
	caseStatement {
	  $$.v.p = new AST(OP_CASEBLOCK,$1.v.p,$1.v.p->context());
	} |
	caseList caseStatement {
	  $$.v.p = $1.v.p; $$.v.p->addChild($2.v.p);
	}
;

caseStatement:
	CASE expr optionalEndStatement statementList {
	  $$.v.p = $1.v.p; $$.v.p->addChild($2.v.p); $$.v.p->addChild($4.v.p);
	}
;

otherwiseClause:
	OTHERWISE statementList {
	  $$.v.p = $2.v.p;
	} |
	/* empty */ {
	  $$.v.p = NULL;
	}
;

forStatement:
	FOR forIndexExpression optionalEndStatement statementList END {
	  $$.v.p = $1.v.p; $$.v.p->addChild($2.v.p); $$.v.p->addChild($4.v.p);
	} |
	FOR forIndexExpression optionalEndStatement statementList error 
           {yyxpt(std::string("'end' to match 'for' statement from line ") + decodeline($1),$5);}
;

forIndexExpression:
	'(' IDENT '=' expr ')' {$$.v.p = $2.v.p; $$.v.p->addChild($4.v.p);} |
	IDENT '=' expr {$$.v.p = $1.v.p; $$.v.p->addChild($3.v.p);} |
	IDENT {$$.v.p = $1.v.p; 
	      $$.v.p->addChild(new AST(OP_RHS,new AST(id_node,$1.v.p->text,$1.v.p->context()),$1.v.p->context())); } |
	'(' IDENT '=' expr error {yyxpt("matching right parenthesis",$1);} |
	'(' IDENT '=' error {yyxpt("indexing expression",$3);} |
	'(' IDENT error {yyxpt("equals operator after loop index",$2);} |
	'(' error {yyxpt("identifier that is the loop variable",$1);} |
	IDENT '=' error {yyxpt("indexing expression",$2);} |
	error {yyxpt("identifier or assignment (id = expr) after 'for' ",$1);} 
;

whileStatement:
	WHILE expr optionalEndStatement statementList END {
	  $$.v.p = $1.v.p; $$.v.p->addChild($2.v.p); $$.v.p->addChild($4.v.p);
	}  |
	WHILE error {yyxpt("test expression after 'while'",$1);} |
	WHILE expr optionalEndStatement statementList error 
	{yyxpt(std::string("'end' to match 'while' statement from line ") + decodeline($1),$5);}
;

ifStatement:
	IF conditionedStatement elseIfBlock elseStatement END {
	  $$.v.p = $1.v.p; $$.v.p->addChild($2.v.p); if ($3.v.p != NULL) $$.v.p->addChild($3.v.p); 
	  if ($4.v.p != NULL) $$.v.p->addChild($4.v.p);
	} |
	IF error {yyxpt("condition expression for 'if'",$1);} |
	IF conditionedStatement elseIfBlock elseStatement error {yyxpt(std::string("'end' to match 'if' statement from line ") + decodeline($1),$5);}
;

conditionedStatement:
	expr optionalEndStatement statementList {
	  $$.v.p = new AST(OP_CSTAT,$1.v.p,$3.v.p,$1.v.p->context());
	} |
	expr error {yyxpt("valid list of statements after condition",$2);}
;

elseIfBlock:
	/* empty */ {$$.v.p = NULL;} |
	elseIfStatementList
	;

elseIfStatementList:
	elseIfStatement {
	  $$.v.p = new AST(OP_ELSEIFBLOCK,$1.v.p,$1.v.p->context());
	} |
	elseIfStatementList elseIfStatement {
	  $$.v.p = $1.v.p; $$.v.p->addChild($2.v.p);
	}
;

elseIfStatement:
	ELSEIF conditionedStatement {
	  $$.v.p = $2.v.p;
	} |
	ELSEIF error {yyxpt("test condition for 'elseif' clause",$1);};

elseStatement:
	ELSE statementList {
	  $$.v.p = $2.v.p;
	} |
	/* empty */ {$$.v.p = NULL;} |
	ELSE error {yyxpt("statement list for 'else' clause",$1);}
;

assignmentStatement:
	symbRefList '=' expr {$$.v.p = new AST(OP_ASSIGN,$1.v.p,$3.v.p,$2.v.i);} |
	symbRefList '=' error {yyxpt("expression in assignment",$2);}
        ;

multiFunctionCall:
	'[' matrixDef ']' '='  IDENT '('  indexList ')' {
	  $5.v.p->addChild(new AST(OP_PARENS,$7.v.p,$6.v.i));
	  $$.v.p = new AST(OP_MULTICALL,$2.v.p,$5.v.p,$1.v.i);
	} |
	'[' matrixDef ']' '=' IDENT  {
	  $5.v.p->addChild(new AST(OP_PARENS,NULL,-1));
	  $$.v.p = new AST(OP_MULTICALL,$2.v.p,$5.v.p,$1.v.i);
	} |
	'[' matrixDef ']' '='  IDENT '('  indexList error 
	{yyxpt("matching right parenthesis",$6);} |
	'[' matrixDef ']' '='  IDENT '('  error 
	{yyxpt("indexing list",$6);} |
	'[' matrixDef ']' '='  IDENT error 
	{yyxpt("left parenthesis",$5);} |	
	'[' matrixDef ']' '=' error 
	{yyxpt("identifier",$4);}
        ; 

expr:
	expr ':' expr {$$.v.p = new AST(OP_COLON,$1.v.p,$3.v.p,$2.v.i);} 
	| expr ':' error {yyxpt("an expression after ':'",$2);}
	| terminal
	| expr '+' expr {$$.v.p = new AST(OP_PLUS,$1.v.p,$3.v.p,$2.v.i);}
	| expr '+' error {yyxpt("an expression after '+'",$2);}
	| expr '-' expr {$$.v.p = new AST(OP_SUBTRACT,$1.v.p,$3.v.p,$2.v.i);}
	| expr '-' error {yyxpt("an expression after '-'",$2);}
	| expr '*' expr {$$.v.p = new AST(OP_TIMES,$1.v.p,$3.v.p,$2.v.i);}
	| expr '*' error {yyxpt("an expression after '*'",$2);}
	| expr '/' expr {$$.v.p = new AST(OP_RDIV,$1.v.p,$3.v.p,$2.v.i);}
	| expr '/' error {yyxpt("an expression after '/'",$2);}
	| expr '\\' expr {$$.v.p = new AST(OP_LDIV,$1.v.p,$3.v.p,$2.v.i);}
	| expr '\\' error {yyxpt("an expression after '\\'",$2);}
	| expr '|' expr {$$.v.p = new AST(OP_OR,$1.v.p,$3.v.p,$2.v.i);}
	| expr '|' error {yyxpt("an expression after '|'",$2);}
	| expr '&' expr {$$.v.p = new AST(OP_AND,$1.v.p,$3.v.p,$2.v.i);}
	| expr '&' error {yyxpt("an expression after '&'",$2);}
	| expr '<' expr {$$.v.p = new AST(OP_LT,$1.v.p,$3.v.p,$2.v.i);}
	| expr '<' error {yyxpt("an expression after '<'",$2);}
	| expr LE  expr {$$.v.p = new AST(OP_LEQ,$1.v.p,$3.v.p,$2.v.i);}
	| expr LE  error {yyxpt("an expression after '<='",$2);}
	| expr '>' expr {$$.v.p = new AST(OP_GT,$1.v.p,$3.v.p,$2.v.i);}
	| expr '>' error {yyxpt("an expression after '>'",$2);}
	| expr GE  expr {$$.v.p = new AST(OP_GEQ,$1.v.p,$3.v.p,$2.v.i);}
	| expr GE  error {yyxpt("an expression after '>='",$2);}
	| expr EQ  expr {$$.v.p = new AST(OP_EQ,$1.v.p,$3.v.p,$2.v.i);}
	| expr EQ  error {yyxpt("an expression after '=='",$2);}
	| expr NE  expr {$$.v.p = new AST(OP_NEQ,$1.v.p,$3.v.p,$2.v.i);}
	| expr NE  error {yyxpt("an expression after '~='",$2);}
	| expr DOTTIMES expr {$$.v.p = new AST(OP_DOT_TIMES,$1.v.p,$3.v.p,$2.v.i);}
	| expr DOTTIMES error {yyxpt("an expression after '.*'",$2);}
	| expr DOTRDIV  expr {$$.v.p = new AST(OP_DOT_RDIV,$1.v.p,$3.v.p,$2.v.i);}
	| expr DOTRDIV  error {yyxpt("an expression after './'",$2);}
	| expr DOTLDIV expr {$$.v.p = new AST(OP_DOT_LDIV,$1.v.p,$3.v.p,$2.v.i);}
	| expr DOTLDIV error {yyxpt("an expression after '.\\'",$2);}
	| '-'  expr %prec NEG {$$.v.p = new AST(OP_NEG,$2.v.p,$1.v.i);}
	| '+'  expr %prec POS {$$.v.p = $2.v.p;}
	| '~' expr %prec NOT {$$.v.p = new AST(OP_NOT,$2.v.p,$1.v.i);}
	| '~' error %prec NOT {yyxpt("an expression after logical not",$2);}
	| expr '^' expr  {$$.v.p = new AST(OP_POWER,$1.v.p,$3.v.p,$2.v.i);}
	| expr '^' error  {yyxpt("an expression after '^'",$2);}
	| expr DOTPOWER expr {$$.v.p = new AST(OP_DOT_POWER,$1.v.p,$3.v.p,$2.v.i);}
	| expr DOTPOWER error {yyxpt("an expression after '.^'",$2);}
	| expr '\''          {$$.v.p = new AST(OP_TRANSPOSE,$1.v.p,$2.v.i);}
	| expr DOTTRANSPOSE  {$$.v.p = new AST(OP_DOT_TRANSPOSE,$1.v.p,$2.v.i);}
	| '(' expr ')'  {$$.v.p = $2.v.p;}
	| '(' expr error  {yyxpt("a right parenthesis after expression to match this one",$1);}
	| '(' error  {yyxpt("an expression after left parenthesis",$1);}
	;

terminal:
        NUMERIC
	| STRING
	| MAGICEND
	| symbRefList {$$.v.p = new AST(OP_RHS,$1.v.p,$1.v.p->context());}
        | '[' matrixDef ']' {$$.v.p = $2.v.p;}
        | '[' error {yyxpt("a matrix definition followed by a right bracket",$1);}
        | '[' rowSeperator matrixDef ']' {$$.v.p = $3.v.p;}
        | '[' matrixDef rowSeperator ']' {$$.v.p = $2.v.p;}
        | '[' rowSeperator matrixDef rowSeperator ']' {$$.v.p = $3.v.p;}
	| '[' ']' {$$.v.p = new AST(OP_EMPTY,NULL,$1.v.i);}
        | '{' cellDef '}' {$$.v.p = $2.v.p;}
        | '{' rowSeperator cellDef '}' {$$.v.p = $3.v.p;}
        | '{' cellDef rowSeperator '}' {$$.v.p = $2.v.p;}
        | '{' rowSeperator cellDef rowSeperator '}' {$$.v.p = $3.v.p;}
	| '{' '}' {$$.v.p = new AST(OP_EMPTY_CELL,NULL,$1.v.i);}
	| '{' error {yyxpt("a cell-array definition followed by a right brace",$1);}
        ;
symbRefList:
	IDENT 
        | symbRefList symbRef {$$.v.p = $1.v.p; $$.v.p->addChild($2.v.p);}
        ;
	
symbRef:
	'(' indexList ')' {$$.v.p = new AST(OP_PARENS,$2.v.p,$1.v.i); }
	| '(' indexList error {yyxpt("matching right parenthesis",$1);}
        | '{' indexList '}' {$$.v.p = new AST(OP_BRACES,$2.v.p,$1.v.i); }
	| '{' indexList error {yyxpt("matching right brace",$1);}
        | '.' IDENT {$$.v.p = new AST(OP_DOT,$2.v.p,$1.v.i); }
	| '.' '(' expr ')' {$$.v.p = new AST(OP_DOTDYN,$3.v.p,$1.v.i);}
        ;

indexElement:
	expr
	| ':' {$$.v.p = new AST(OP_ALL,NULL,$1.v.i);}
	| '/' IDENT '=' expr {$$.v.p = new AST(OP_KEYWORD,$2.v.p,$4.v.p,$1.v.i);}
	| '/' IDENT '=' error {yyxpt("expecting expression after '=' in keyword assignment",$3);}
	| '/' IDENT {$$.v.p = new AST(OP_KEYWORD,$2.v.p,$1.v.i);}
	| '/' error {yyxpt("expecting keyword identifier after '/' in keyword assignment",$1);}
        ;

indexList:
	indexElement | 
        indexList ',' indexElement {$$.v.p = $1.v.p; $$.v.p->addPeer($3.v.p);}
        ;

cellDef:
       rowDef {$$.v.p = new AST(OP_BRACES,$1.v.p,$1.v.p->context());}|
       cellDef rowSeperator rowDef {$$.v.p = $1.v.p; $$.v.p->addChild($3.v.p);}
       ;

matrixDef:
       rowDef {$$.v.p = new AST(OP_BRACKETS,$1.v.p,$1.v.p->context());}|
       matrixDef rowSeperator rowDef {$$.v.p = $1.v.p; $$.v.p->addChild($3.v.p);} 
       ;

rowSeperator:
       ENDSTMNT | ENDQSTMNT
       ;

columnSep:
       ',' | '#'
       ;

rowDef:
       expr {$$.v.p = new AST(OP_SEMICOLON,$1.v.p,$1.v.p->context());} |
       rowDef  columnSep expr {$$.v.p = $1.v.p; $$.v.p->addChild($3.v.p);}
       ;

%%

namespace FreeMat {
  
  void resetParser() {
    mainAST = NULL;
    mainMDef = NULL;
  }
  
  ASTPtr getParsedScriptBlock() {
    return mainAST;
  }
  
  MFunctionDef* getParsedFunctionDef() {
    return mainMDef;
  }
  
  ParserState parseState() {
    if (mainAST != NULL) 
      return ScriptBlock;
    else
      return FuncDef;
  }
  
  ParserState parseString(char *txt) {
/*     yydebug = 1; 	*/
    resetParser();
    interactiveMode = true;
    setLexBuffer(txt);
    yyparse();
    return parseState();
  }
  
  ParserState parseFile(FILE *fp, const char* fname) {
//    yydebug = 1; 
    resetParser();
    interactiveMode = false;
    parsing_filename = fname;
    setLexFile(fp);
    yyparse();
    return parseState();
  }
  
}
