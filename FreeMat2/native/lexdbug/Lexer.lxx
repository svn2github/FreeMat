%{
// Copyright (c) 2002, 2003 Samit Basu
// 
// Permission is hereby granted, free of charge, to any person obtaining a 
// copy of this software and associated documentation files (the "Software"), 
// to deal in the Software without restriction, including without limitation 
// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
// and/or sell copies of the Software, and to permit persons to whom the 
// Software is furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.

#include "Parser.h"
#include "Reserved.hpp"
#include <stdlib.h>
#include <string.h>

using namespace FreeMat;

extern int lineNumber;

reservedWordStruct ts, *p;
 
  // These are the possible contexts in which end's can occur. 
  typedef enum {
    context_for,
    context_while,
    context_if,
    context_try,
    context_switch,
    context_index,
    context_matrix,
    context_cell,
    context_error
  } end_context;

  int stackCount;
  int stateStack[1000];
  int contextCount;
  end_context contextStack[1000]; 
  end_context thisContext;
  int rettoken;
  int lineNumber;
  int continuationCount;
  bool firstToken;
  bool minusisneg;
  
  void pushState(int state) {
    stateStack[stackCount] = state;
    printf("push top state is %d\n",stateStack[stackCount]);
    stackCount++;
  }
  
  int popState() {
    if (stackCount < 1)
	return 0;
    stackCount--;
    printf("pop top state is %d\n",stateStack[stackCount]);
    return stateStack[stackCount];
  }
  
  int topState() {
    return stateStack[stackCount-1];
  }
 
  void pushContext(end_context context) { 
    contextStack[contextCount] = context;
    contextCount++;
  }

  end_context popContext(char t) {
    if (contextCount < 1) {
      switch (t) {
      case ')':
	throw ("unexpected ')' encountered");
      case '}':
	throw ("unexpected '}' encountered");
      case ']':
	throw ("unexpected ']' encountered");
      case 'x':
	throw ("unexpected 'end' encountered");
      }
    } 
    contextCount--;
    return contextStack[contextCount];
  }

  end_context topContext() {
    return contextStack[contextCount-1];
  }

%}

Word            [a-zA-Z][a-zA-Z0-9_]*
Digit		[0-9]
Sign		([\+]|[\-])
FltSuffix	([f]|[F])
DblSuffix	([d]|[D])
SignedInt	{Sign}?{Digit}+
Expo		([e]|[E])
ExponentPart	{Expo}{SignedInt}?
Integer		{Digit}+
Float1		{Digit}+[\.]{Digit}+?{ExponentPart}?{FltSuffix}
Float2		[\.]{Digit}+{ExponentPart}?{FltSuffix}
Float3		{Digit}+{ExponentPart}{FltSuffix}
Float4		{Digit}+{FltSuffix}
Float5		{Digit}+[\.]{Digit}+?{ExponentPart}?{DblSuffix}?
Float6		[\.]{Digit}+{ExponentPart}?{DblSuffix}?
Float7		{Digit}+{ExponentPart}{DblSuffix}?
Float8		{Digit}+{DblSuffix}
FloatingPoint	({Float1}|{Float2}|{Float3}|{Float4})
DoubleFloatingPoint	({Float5}|{Float6}|{Float7}|{Float8})
Whitespace      [ \t]
Commentline     "%".*
Newline         ("\r\n"|\n)
String          [\'][^\'\n\r]*[\']
ArgDot          \.[^*\\/\^\'][^ \t;\n\r]*
ArgFSlash	\/[a-zA-Z\.\///][^ \t;\n\r]*
ArgRSlash	\\[a-zA-Z\.\///][^ \t;\n\r]*
ArgTilde	~[^=][^ \t;\n\r]*
Argument	(-?[a-zA-Z0-9][^ \t;\n\r]*)|{ArgDot}|{ArgFSlash}|{ArgRSlash}|{ArgTilde}
SpecialArgument ({Argument}|{String})

%x IdentDereference
%x TransposeCheck
%x Scanning
%x SpecialSyntax
%x SpecialSyntaxStart
%x SpecialSyntaxArgs
%x str
%x Mscan
%%

	char string_buf[4095];
	char *string_buf_ptr;

{Commentline} {
}

{Newline} {
  lineNumber++;
}

{Whitespace}+ {
}

";" {
}

. {
  yyless(0);
  BEGIN(SpecialSyntax);
}

<SpecialSyntax>{Word}({Whitespace}+{SpecialArgument})+";"?{Newline} {
  yyless(0);
  BEGIN(SpecialSyntaxStart);
}

<SpecialSyntax>. {
  yyless(0);
  BEGIN(Scanning);
}

<SpecialSyntaxStart>{Word} {
  /* Check for a reserved word... */
  ts.word = yytext;
  p = (reservedWordStruct*)
    bsearch(&ts,reservedWord,RESWORDCOUNT,
	    sizeof(reservedWordStruct),
	    compareReservedWord);
  if (p!=NULL) {
    yyless(0);
    BEGIN(Scanning);
  } else {
    BEGIN(SpecialSyntaxArgs);  
    return SPECIALCALL;
  }
}

<SpecialSyntaxArgs>{Whitespace}+ {
}

<SpecialSyntaxArgs>{Argument} {
  return STRING;
}

<SpecialSyntaxArgs>{String} {
  yytext[yyleng-1] = 0;
  return STRING;
}

<SpecialSyntaxArgs>";\n"  {
  lineNumber++;
  BEGIN(INITIAL);
  return ENDQSTMNT;
}

<SpecialSyntaxArgs>";"  {
  BEGIN(INITIAL);
  return ENDQSTMNT;
}

<SpecialSyntaxArgs>"\r\n"|\n {
  lineNumber++;
  BEGIN(INITIAL);
  return ENDSTMNT;
}

<Scanning,Mscan>"==" {
  return EQ;
}

<Scanning,Mscan>".*" {			
  return DOTTIMES;
}

<Scanning,Mscan>"./" {
  return DOTRDIV;
}

<Scanning,Mscan>".\\" {
  return DOTLDIV;
}

<Scanning,Mscan>"<=" {			
  return LE;
}

<Scanning,Mscan>">=" {
  return GE;
}

<Scanning,Mscan>"~=" {
  return NE;
}

<Scanning,Mscan>".^" {
  return DOTPOWER;
}

<Scanning,Mscan>".\'" {
  return DOTTRANSPOSE;
}

<Scanning,Mscan>";\n"  {
  lineNumber++;
  firstToken = true;
  BEGIN(INITIAL);
  return ENDQSTMNT;
}

<Scanning,Mscan>";"  {
  firstToken = true;
  BEGIN(INITIAL);
  return ENDQSTMNT;
}

<Scanning,Mscan>"," {
  BEGIN(Scanning);
  return ',';
}

<Scanning,Mscan>"\r\n"|\n {
  lineNumber++;
  firstToken = true;
  BEGIN(INITIAL);
  return ENDSTMNT;
}

<Scanning,Mscan>"(" {
  pushState(YYSTATE);
  pushContext(context_index);
  BEGIN(Scanning);
  return '(';
}

<Scanning,Mscan>"{" {
  pushState(YYSTATE);
  pushContext(context_cell);
  BEGIN(Mscan);
  return '{';
}

<Scanning,Mscan>"[" {
  pushState(YYSTATE);
  pushContext(context_matrix);
  BEGIN(Mscan);
  return '[';
}

<Scanning,Mscan>")" {
  popContext(')');
  if (topState() == Scanning) {
    BEGIN(TransposeCheck);
    return ')'; 
  } else {
    BEGIN(popState());
    return REFRPAREN;
  }
}

<Scanning,Mscan>"}" {
  popContext('}');
  if (topState() == Scanning) {
    BEGIN(TransposeCheck);
    return '}';
  } else {
    BEGIN(popState());
    return REFRBRACE;
  }
}

<Scanning,Mscan>"]" {
  popContext(']');
  pushState(YYSTATE);
  BEGIN(TransposeCheck);
  return ']';
}

<Mscan>[a-zA-Z0-9)]{Whitespace}+[+-][a-zA-Z0-9(+-] {
  int i;
  char *yycopy = strdup(yytext);
  for (i=yyleng-1;i>=0;--i) 
    if (i != 1)
      unput(yycopy[i]);
    else
      unput(',');
  free(yycopy);
}

<Scanning,Mscan>[ \f\t] {
  /* skip */
}

<Scanning,Mscan>"..."{Whitespace}*{Newline} {
  lineNumber++;
  continuationCount++;
  firstToken = false;
  BEGIN(Scanning);
}

<Scanning,Mscan>{Commentline} {
  /* skip */
}

<Scanning,Mscan>\'  string_buf_ptr = string_buf; BEGIN(str);

<str>\' {
	BEGIN(Scanning); 
	*string_buf_ptr = '\0';
	return STRING;
	}

<str>\\n *string_buf_ptr++ = 10;
<str>\\t *string_buf_ptr++ = 9;
<str>\\r *string_buf_ptr++ = 13;
<str>\\b *string_buf_ptr++ = 8;
<str>\\f *string_buf_ptr++ = 12;
<str>\\(.|\n)  *string_buf_ptr++ = yytext[1];

<str>[^\\\n\']+  {
                   char *yptr = yytext;
                   while ( *yptr )
                           *string_buf_ptr++ = *yptr++;
                 }

<Scanning,Mscan>{Word} {
  /* Search for the identifier in the keyword table */
  ts.word = yytext;
  p = (reservedWordStruct*) 
    bsearch(&ts,reservedWord,RESWORDCOUNT,
	    sizeof(reservedWordStruct),
	    compareReservedWord);
  if (p==NULL) {
    pushState(YYSTATE);
    BEGIN(IdentDereference);
    return IDENT;
  } else {
    // Check for reserved words that trigger end-context changes
    rettoken = p->token;
    switch (p->token) {
    case ELSEIF:
      BEGIN(Mscan);
      break;
    case CASE:
      BEGIN(Mscan);
      break;
    case SWITCH:
      pushContext(context_switch);
      BEGIN(Mscan);
      break;
    case FOR:
      pushContext(context_for);
      BEGIN(Mscan);
      break;
    case WHILE:
      pushContext(context_while);
      BEGIN(Mscan);
      break;
    case TRY:
      pushContext(context_try);
      break;
    case IF:
      pushContext(context_if);
      BEGIN(Mscan);
      break;
    case END:
      thisContext = popContext('x');
      switch (thisContext) {
      case context_for:
	rettoken = ENDFOR;
	break;
      case context_switch:
	rettoken = ENDSWITCH;
	break;
      case context_while:
	rettoken = ENDWHILE;
	break;
      case context_try:
	rettoken = ENDTRY;
	break;
      case context_if:
	rettoken = ENDIF;
	break;
      default:
	pushContext(thisContext);
	rettoken = END;
      }
    }
    return rettoken;
  }
}

<IdentDereference>{Whitespace}*"..."{Whitespace}*{Newline} {
  lineNumber++;
  continuationCount++;
  firstToken = false;
}

<IdentDereference>"."{Word} {
  return FIELD;
}

<IdentDereference>"(" {
  pushState(IdentDereference);
  pushContext(context_index);
  BEGIN(Scanning);
  return REFLPAREN;
}

<IdentDereference>"{" {
  pushState(IdentDereference);
  pushContext(context_cell);
  BEGIN(Scanning);
  return REFLBRACE;
}

<IdentDereference>"'" {
  BEGIN(popState());
  return *yytext;
}

<IdentDereference>[^"'"] {
  unput(yytext[0]);
  BEGIN(popState());
}

<Scanning,Mscan>{FloatingPoint} {
  pushState(YY_START);
  BEGIN(TransposeCheck);
  return NUMERIC;
}

<Scanning,Mscan>{DoubleFloatingPoint} {
  pushState(YY_START);
  BEGIN(TransposeCheck);
  return NUMERIC;
}

<Scanning,Mscan>{Integer} {
  pushState(YY_START);
  BEGIN(TransposeCheck);
  return NUMERIC;
}

<Scanning,Mscan>. {
  return *yytext;
}

<TransposeCheck>"'" {
  BEGIN(popState());
  return *yytext;
}

<TransposeCheck>[^"'"] {
  BEGIN(popState());
  unput(yytext[0]);
}

%%

int yywrap() {
  return 1;
}

int main() {
    while (yylex() > 0) {
	printf("token = %s\r\n",yytext);
   }
}
